// asap.ci - ASAP in the Ci programming language
//
// Copyright (C) 2010-2011  Piotr Fusik
//
// This file is part of ASAP (Another Slight Atari Player),
// see http://asap.sourceforge.net
//
// ASAP is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published
// by the Free Software Foundation; either version 2 of the License,
// or (at your option) any later version.
//
// ASAP is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty
// of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with ASAP; if not, write to the Free Software Foundation, Inc.,
// 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

namespace net.Sf.Asap;

public const int VersionMajor = 2;
public const int VersionMinor = 1;
public const int VersionMicro = 3;
public const string Version = "2.1.3";

/// Maximum length of a supported input file.
/// You may assume that files longer than this are not supported by ASAP.
public const int ModuleMax = 65000;

/// Maximum number of songs in a file.
public const int SongsMax = 32;

/// Output sample rate.
public const int SampleRate = 44100;

/// WAV file header length.
// TODO: <seealso cref="GetWavHeader" />
public const int WavHeaderBytes = 44;

/// Format of output samples.
public enum ASAP_SampleFormat
{
	/// Unsigned 8-bit.
	U8,
	/// Signed 16-bit little-endian.
	S16LE,
	/// Signed 16-bit big-endian.
	S16BE
}

/// Information about a music file.
public class ASAP_ModuleInfo
{
	/// Author's name.
	/// A nickname may be included in parentheses after the real name.
	/// Multiple authors are separated with `" & "`.
	/// Empty string means the author is unknown.
	public string(127) author;

	/// Music title.
	/// Empty string means the title is unknown.
	public string(127) name;

	/// Music creation date.
	/// Some of the possible formats are:
	/// * YYYY
	/// * MM/YYYY
	/// * DD/MM/YYYY
	/// * YYYY-YYYY
	///
	/// Empty string means the date is unknown.
	public string(127) date;

	/// 1 for mono or 2 for stereo.
	public int channels;

	/// Number of songs in the file.
	public int songs;

	/// 0-based index of the "main" song.
	/// The specified song should be played by default.
	public int default_song;

	/// Lengths of songs.
	/// Each element of the array represents length of one song,
	/// in milliseconds. -1 means the length is indeterminate.
	public int[32] durations;

	/// Information about finite vs infinite songs.
	/// Each element of the array represents one song, and is:
	/// * `true` if the song loops
	/// * `false` if the song stops
	public bool[32] loops;

	bool ntsc;
	int type;
	int fastplay;
	int music;
	int init;
	int player;
	int covox_addr;
	int header_len;
	byte[32] song_pos;
}

class PokeyState
{
	int audctl;
	bool init;
	int poly_index;
	int div_cycles;
	int mute1;
	int mute2;
	int mute3;
	int mute4;
	int audf1;
	int audf2;
	int audf3;
	int audf4;
	int audc1;
	int audc2;
	int audc3;
	int audc4;
	int tick_cycle1;
	int tick_cycle2;
	int tick_cycle3;
	int tick_cycle4;
	int period_cycles1;
	int period_cycles2;
	int period_cycles3;
	int period_cycles4;
	int reload_cycles1;
	int reload_cycles3;
	int out1;
	int out2;
	int out3;
	int out4;
	int delta1;
	int delta2;
	int delta3;
	int delta4;
	int skctl;
	int[888] delta_buffer;
}

class ASAP_State
{
	int cycle;
	int cpu_pc;
	int cpu_a;
	int cpu_x;
	int cpu_y;
	int cpu_s;
	int cpu_nz;
	int cpu_c;
	int cpu_vdi;
	int scanline_number;
	int nearest_event_cycle;
	int next_scanline_cycle;
	int timer1_cycle;
	int timer2_cycle;
	int timer4_cycle;
	int irqst;
	int extra_pokey_mask;
	int consol;
	int nmist;
	byte[4] covox;
	PokeyState() base_pokey;
	PokeyState() extra_pokey;
	int sample_offset;
	int sample_index;
	int samples;
	int iir_acc_left;
	int iir_acc_right;
	public ASAP_ModuleInfo() module_info;
	int tmc_per_frame;
	int tmc_per_frame_counter;
	int current_song;
	int current_duration;
	int blocks_played;
	int silence_cycles;
	int silence_cycles_counter;
	byte[511] poly9_lookup;
	byte[16385] poly17_lookup;
	byte[65536] memory;
}

const int NeverCycle = 0x800000;

const int DeltaShiftPOKEY = 20;
const int DeltaShiftGTIA  = 20;
const int DeltaShiftCOVOX = 17;

// TODO: flags
const int MuteFrequency = 1;
const int MuteInit = 2;
const int MuteUser = 4;
const int MuteSerialInput = 8;

void PokeySound_InitializeChip(PokeyState pst)
{
	pst.audctl = 0;
	pst.init = false;
	pst.poly_index = 15 * 31 * 131071;
	pst.div_cycles = 28;
	pst.mute1 = MuteFrequency | MuteUser;
	pst.mute2 = MuteFrequency | MuteUser;
	pst.mute3 = MuteFrequency | MuteUser;
	pst.mute4 = MuteFrequency | MuteUser;
	pst.audf1 = 0;
	pst.audf2 = 0;
	pst.audf3 = 0;
	pst.audf4 = 0;
	pst.audc1 = 0;
	pst.audc2 = 0;
	pst.audc3 = 0;
	pst.audc4 = 0;
	pst.tick_cycle1 = NeverCycle;
	pst.tick_cycle2 = NeverCycle;
	pst.tick_cycle3 = NeverCycle;
	pst.tick_cycle4 = NeverCycle;
	pst.period_cycles1 = 28;
	pst.period_cycles2 = 28;
	pst.period_cycles3 = 28;
	pst.period_cycles4 = 28;
	pst.reload_cycles1 = 28;
	pst.reload_cycles3 = 28;
	pst.out1 = 0;
	pst.out2 = 0;
	pst.out3 = 0;
	pst.out4 = 0;
	pst.delta1 = 0;
	pst.delta2 = 0;
	pst.delta3 = 0;
	pst.delta4 = 0;
	pst.skctl = 3;
	pst.delta_buffer.Clear();
}

void PokeySound_Initialize(ASAP_State ast)
{
	int reg = 0x1ff;
	for (int i = 0; i < 511; i++) {
		reg = (reg >> 5 ^ reg) & 1 << 8 + reg >> 1;
		ast.poly9_lookup[i] = reg.LowByte;
	}
	reg = 0x1ffff;
	for (int i = 0; i < 16385; i++) {
		reg = (reg >> 5 ^ reg) & 0xff << 9 + reg >> 8;
		ast.poly17_lookup[i] = (reg >> 1).LowByte;
	}
	ast.sample_offset = 0;
	ast.sample_index = 0;
	ast.samples = 0;
	ast.iir_acc_left = 0;
	ast.iir_acc_right = 0;
	PokeySound_InitializeChip(ast.base_pokey);
	PokeySound_InitializeChip(ast.extra_pokey);
}

macro ASAP_MAIN_CLOCK(ast)    ((ast).module_info.ntsc ? 1789772 : 1773447)
macro CYCLE_TO_SAMPLE(cycle)  (((cycle) * SampleRate + ast.sample_offset) / ASAP_MAIN_CLOCK(ast))

/// Fills `delta_buffer` up to `current_cycle` basing on current AUDF/AUDC/AUDCTL values.
void PokeySound_GenerateUntilCycle(ASAP_State ast, PokeyState pst, int current_cycle)
{
	for (;;) {
		int cycle = current_cycle;
		if (cycle > pst.tick_cycle1)
			cycle = pst.tick_cycle1;
		if (cycle > pst.tick_cycle2)
			cycle = pst.tick_cycle2;
		if (cycle > pst.tick_cycle3)
			cycle = pst.tick_cycle3;
		if (cycle > pst.tick_cycle4)
			cycle = pst.tick_cycle4;
		if (cycle == current_cycle)
			break;

		const byte[15] poly4_lookup = { 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1 };
		const byte[31] poly5_lookup = {
			0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1,
			0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1 };
		macro DO_TICK(ch) {
			if (pst.init) {
				switch (pst.audc##ch >> 4) {
				case 10:
				case 14:
					pst.out##ch ^= 1;
					pst.delta_buffer[CYCLE_TO_SAMPLE(cycle)] += pst.delta##ch = -pst.delta##ch;
					break;
				default:
					break;
				}
			}
			else {
				int poly = cycle + pst.poly_index - (ch - 1);
				int newout = pst.out##ch;
				switch (pst.audc##ch >> 4) {
				case 0:
					if (poly5_lookup[poly % 31] != 0) {
						if (pst.audctl & 0x80 != 0)
							newout = ast.poly9_lookup[poly % 511] & 1;
						else {
							poly %= 131071;
							newout = (ast.poly17_lookup[poly >> 3] >> (poly & 7)) & 1;
						}
					}
					break;
				case 2:
				case 6:
					newout ^= poly5_lookup[poly % 31];
					break;
				case 4:
					if (poly5_lookup[poly % 31] != 0)
						newout = poly4_lookup[poly % 15];
					break;
				case 8:
					if (pst.audctl & 0x80 != 0)
						newout = ast.poly9_lookup[poly % 511] & 1;
					else {
						poly %= 131071;
						newout = (ast.poly17_lookup[poly >> 3] >> (poly & 7)) & 1;
					}
					break;
				case 10:
				case 14:
					newout ^= 1;
					break;
				case 12:
					newout = poly4_lookup[poly % 15];
					break;
				default:
					break;
				}
				if (newout != pst.out##ch) {
					pst.out##ch = newout;
					pst.delta_buffer[CYCLE_TO_SAMPLE(cycle)] += pst.delta##ch = -pst.delta##ch;
				}
			}
		}

		if (cycle == pst.tick_cycle3) {
			pst.tick_cycle3 += pst.period_cycles3;
			if (pst.audctl & 4 != 0 && pst.delta1 > 0 && pst.mute1 == 0)
				pst.delta_buffer[CYCLE_TO_SAMPLE(cycle)] += pst.delta1 = -pst.delta1;
			DO_TICK(3);
		}
		if (cycle == pst.tick_cycle4) {
			pst.tick_cycle4 += pst.period_cycles4;
			if (pst.audctl & 8 != 0)
				pst.tick_cycle3 = cycle + pst.reload_cycles3;
			if (pst.audctl & 2 != 0 && pst.delta2 > 0 && pst.mute2 == 0)
				pst.delta_buffer[CYCLE_TO_SAMPLE(cycle)] += pst.delta2 = -pst.delta2;
			DO_TICK(4);
		}
		if (cycle == pst.tick_cycle1) {
			pst.tick_cycle1 += pst.period_cycles1;
			if (pst.skctl & 0x88 == 8) // two-tone, sending 1 (i.e. timer1)
				pst.tick_cycle2 = cycle + pst.period_cycles2;
			DO_TICK(1);
		}
		if (cycle == pst.tick_cycle2) {
			pst.tick_cycle2 += pst.period_cycles2;
			if (pst.audctl & 0x10 != 0)
				pst.tick_cycle1 = cycle + pst.reload_cycles1;
			else if (pst.skctl & 8 != 0) // two-tone
				pst.tick_cycle1 = cycle + pst.period_cycles1;
			DO_TICK(2);
		}
	}
}

#if APOKEYSND
macro CURRENT_CYCLE()  (0)
macro CURRENT_SAMPLE() (0)
macro DO_STORE(reg) {
	if (data == pst.reg)
		break;
	pst.reg = data;
}
#else
macro CURRENT_CYCLE()  (ast.cycle)
macro CURRENT_SAMPLE() (CYCLE_TO_SAMPLE(ast.cycle))
macro DO_STORE(reg) {
	if (data == pst.reg)
		break;
	PokeySound_GenerateUntilCycle(ast, pst, ast.cycle);
	pst.reg = data;
}
#endif // APOKEYSND

macro MUTE_CHANNEL(ch, cond, mask) {
	if (cond) {
		pst.mute##ch |= mask;
		pst.tick_cycle##ch = NeverCycle;
	}
	else {
		pst.mute##ch &= ~mask;
		if (pst.tick_cycle##ch == NeverCycle && pst.mute##ch == 0)
			pst.tick_cycle##ch = CURRENT_CYCLE();
	}
}

void PokeySound_PutByte(ASAP_State ast, int addr, int data)
{
	PokeyState pst = addr & ast.extra_pokey_mask != 0 ? ast.extra_pokey : ast.base_pokey;
	switch (addr & 0xf) {
	case 0x00:
		DO_STORE(audf1);
		const int UltrasoundCycles = 112;
		macro DO_ULTRASOUND(ch) {
			MUTE_CHANNEL(ch, pst.period_cycles##ch <= UltrasoundCycles
				&& (pst.audc##ch >> 4 == 10 || pst.audc##ch >> 4 == 14), MuteFrequency);
		}
		switch (pst.audctl & 0x50) {
		case 0x00:
			pst.period_cycles1 = pst.div_cycles * (data + 1);
			break;
		case 0x10:
			pst.period_cycles2 = pst.div_cycles * (data + 256 * pst.audf2 + 1);
			pst.reload_cycles1 = pst.div_cycles * (data + 1);
			DO_ULTRASOUND(2);
			break;
		case 0x40:
			pst.period_cycles1 = data + 4;
			break;
		case 0x50:
			pst.period_cycles2 = data + 256 * pst.audf2 + 7;
			pst.reload_cycles1 = data + 4;
			DO_ULTRASOUND(2);
			break;
		}
		DO_ULTRASOUND(1);
		break;
	case 0x01:
		macro DO_AUDC(ch) {
			DO_STORE(audc##ch);
			if (data & 0x10 != 0) {
				data = (data & 0xf) << DeltaShiftPOKEY;
				if (pst.mute##ch & MuteUser == 0)
					pst.delta_buffer[CURRENT_SAMPLE()]
						+= pst.delta##ch > 0 ? data - pst.delta##ch : data;
				pst.delta##ch = data;
			}
			else {
				data = (data & 0xf) << DeltaShiftPOKEY;
				DO_ULTRASOUND(ch);
				if (pst.delta##ch > 0) {
					if (pst.mute##ch & MuteUser == 0)
						pst.delta_buffer[CURRENT_SAMPLE()]
							+= data - pst.delta##ch;
					pst.delta##ch = data;
				}
				else
					pst.delta##ch = -data;
			}
			break;
		}
		DO_AUDC(1);
	case 0x02:
		DO_STORE(audf2);
		switch (pst.audctl & 0x50) {
		case 0x00:
		case 0x40:
			pst.period_cycles2 = pst.div_cycles * (data + 1);
			break;
		case 0x10:
			pst.period_cycles2 = pst.div_cycles * (pst.audf1 + 256 * data + 1);
			break;
		case 0x50:
			pst.period_cycles2 = pst.audf1 + 256 * data + 7;
			break;
		}
		DO_ULTRASOUND(2);
		break;
	case 0x03:
		DO_AUDC(2);
	case 0x04:
		DO_STORE(audf3);
		switch (pst.audctl & 0x28) {
		case 0x00:
			pst.period_cycles3 = pst.div_cycles * (data + 1);
			break;
		case 0x08:
			pst.period_cycles4 = pst.div_cycles * (data + 256 * pst.audf4 + 1);
			pst.reload_cycles3 = pst.div_cycles * (data + 1);
			DO_ULTRASOUND(4);
			break;
		case 0x20:
			pst.period_cycles3 = data + 4;
			break;
		case 0x28:
			pst.period_cycles4 = data + 256 * pst.audf4 + 7;
			pst.reload_cycles3 = data + 4;
			DO_ULTRASOUND(4);
			break;
		}
		DO_ULTRASOUND(3);
		break;
	case 0x05:
		DO_AUDC(3);
	case 0x06:
		DO_STORE(audf4);
		switch (pst.audctl & 0x28) {
		case 0x00:
		case 0x20:
			pst.period_cycles4 = pst.div_cycles * (data + 1);
			break;
		case 0x08:
			pst.period_cycles4 = pst.div_cycles * (pst.audf3 + 256 * data + 1);
			break;
		case 0x28:
			pst.period_cycles4 = pst.audf3 + 256 * data + 7;
			break;
		}
		DO_ULTRASOUND(4);
		break;
	case 0x07:
		DO_AUDC(4);
	case 0x08:
		DO_STORE(audctl);
		pst.div_cycles = data & 1 != 0 ? 114 : 28;
		// TODO: tick_cycles
		switch (data & 0x50) {
		case 0x00:
			pst.period_cycles1 = pst.div_cycles * (pst.audf1 + 1);
			pst.period_cycles2 = pst.div_cycles * (pst.audf2 + 1);
			break;
		case 0x10:
			pst.period_cycles1 = pst.div_cycles * 256;
			pst.period_cycles2 = pst.div_cycles * (pst.audf1 + 256 * pst.audf2 + 1);
			pst.reload_cycles1 = pst.div_cycles * (pst.audf1 + 1);
			break;
		case 0x40:
			pst.period_cycles1 = pst.audf1 + 4;
			pst.period_cycles2 = pst.div_cycles * (pst.audf2 + 1);
			break;
		case 0x50:
			pst.period_cycles1 = 256;
			pst.period_cycles2 = pst.audf1 + 256 * pst.audf2 + 7;
			pst.reload_cycles1 = pst.audf1 + 4;
			break;
		}
		DO_ULTRASOUND(1);
		DO_ULTRASOUND(2);
		switch (data & 0x28) {
		case 0x00:
			pst.period_cycles3 = pst.div_cycles * (pst.audf3 + 1);
			pst.period_cycles4 = pst.div_cycles * (pst.audf4 + 1);
			break;
		case 0x08:
			pst.period_cycles3 = pst.div_cycles * 256;
			pst.period_cycles4 = pst.div_cycles * (pst.audf3 + 256 * pst.audf4 + 1);
			pst.reload_cycles3 = pst.div_cycles * (pst.audf3 + 1);
			break;
		case 0x20:
			pst.period_cycles3 = pst.audf3 + 4;
			pst.period_cycles4 = pst.div_cycles * (pst.audf4 + 1);
			break;
		case 0x28:
			pst.period_cycles3 = 256;
			pst.period_cycles4 = pst.audf3 + 256 * pst.audf4 + 7;
			pst.reload_cycles3 = pst.audf3 + 4;
			break;
		}
		DO_ULTRASOUND(3);
		DO_ULTRASOUND(4);
		macro DO_INIT(ch, cond) { MUTE_CHANNEL(ch, pst.init && cond, MuteInit); }
		DO_INIT(1, data & 0x40 == 0);
		DO_INIT(2, data & 0x50 != 0x50);
		DO_INIT(3, data & 0x20 == 0);
		DO_INIT(4, data & 0x28 != 0x28);
		break;
	case 0x09:
		// TODO: reload_cycles, out
		macro DO_STIMER(ch) {
			if (pst.tick_cycle##ch != NeverCycle)
				pst.tick_cycle##ch = ast.cycle + pst.period_cycles##ch;
		}
		DO_STIMER(1);
		DO_STIMER(2);
		DO_STIMER(3);
		DO_STIMER(4);
		break;
	case 0x0f:
		DO_STORE(skctl);
		bool init = data & 3 == 0;
		if (pst.init && !init)
			pst.poly_index = (pst.audctl & 0x80 != 0 ? 15 * 31 * 511 - 1 : 15 * 31 * 131071 - 1) - ast.cycle;
		pst.init = init;
		DO_INIT(1, pst.audctl & 0x40 == 0);
		DO_INIT(2, pst.audctl & 0x50 != 0x50);
		DO_INIT(3, pst.audctl & 0x20 == 0);
		DO_INIT(4, pst.audctl & 0x28 != 0x28);
		MUTE_CHANNEL(3, data & 0x10 != 0, MuteSerialInput);
		MUTE_CHANNEL(4, data & 0x10 != 0, MuteSerialInput);
		break;
	default:
		break;
	}
}

int PokeySound_GetRandom(ASAP_State ast, int addr, int cycle)
{
	PokeyState pst = addr & ast.extra_pokey_mask != 0 ? ast.extra_pokey : ast.base_pokey;
	if (pst.init)
		return 0xff;
	int i = cycle + pst.poly_index;
	if (pst.audctl & 0x80 != 0)
		return ast.poly9_lookup[i % 511];
	else {
		i %= 131071;
		int j = i >> 3;
		i &= 7;
		return (ast.poly17_lookup[j] >> i + ast.poly17_lookup[j + 1] << (8 - i)) & 0xff;
	}
}

void end_frame(ASAP_State ast, PokeyState pst, int cycle_limit)
{
	PokeySound_GenerateUntilCycle(ast, pst, cycle_limit);
	pst.poly_index += cycle_limit;
	int m = pst.audctl & 0x80 != 0 ? 15 * 31 * 511 : 15 * 31 * 131071;
	if (pst.poly_index >= 2 * m)
		pst.poly_index -= m;
	if (pst.tick_cycle1 != NeverCycle)
		pst.tick_cycle1 -= cycle_limit;
	if (pst.tick_cycle2 != NeverCycle)
		pst.tick_cycle2 -= cycle_limit;
	if (pst.tick_cycle3 != NeverCycle)
		pst.tick_cycle3 -= cycle_limit;
	if (pst.tick_cycle4 != NeverCycle)
		pst.tick_cycle4 -= cycle_limit;
}

void PokeySound_StartFrame(ASAP_State ast)
{
	ast.base_pokey.delta_buffer.Clear();
	if (ast.extra_pokey_mask != 0)
		ast.extra_pokey.delta_buffer.Clear();
}

void PokeySound_EndFrame(ASAP_State ast, int current_cycle)
{
	end_frame(ast, ast.base_pokey, current_cycle);
	if (ast.extra_pokey_mask != 0)
		end_frame(ast, ast.extra_pokey, current_cycle);
	ast.sample_offset += current_cycle * SampleRate;
	ast.sample_index = 0;
	int clk = ASAP_MAIN_CLOCK(ast);
	ast.samples = ast.sample_offset / clk;
	ast.sample_offset %= clk;
}

/// Fills buffer with samples from `delta_buffer`.
int PokeySound_Generate(ASAP_State ast, byte[] buffer, int buffer_offset, int blocks, ASAP_SampleFormat format)
{
	int i = ast.sample_index;
	int samples = ast.samples;
	int acc_left = ast.iir_acc_left;
	int acc_right = ast.iir_acc_right;
	if (blocks < samples - i)
		samples = i + blocks;
	else
		blocks = samples - i;
	for (; i < samples; i++) {
		acc_left += ast.base_pokey.delta_buffer[i] - (acc_left * 3 >> 10);
#if FLASH
//		var sample : Number = acc_left / 33553408;
//		buffer.writeFloat(sample);
//		if (ast.extra_pokey_mask != 0) {
//			acc_right += ast.extra_pokey.delta_buffer[i] - (acc_right * 3 >> 10);
//			sample = acc_right / 33553408;
//		}
//		buffer.writeFloat(sample);
#else
		int sample = acc_left >> 10;
		macro STORE_SAMPLE() {
			if (sample < -32767)
				sample = -32767;
			else if (sample > 32767)
				sample = 32767;
			switch (format) {
			case ASAP_SampleFormat.U8:
				buffer[buffer_offset++] = sample >> 8 + 128;
				break;
			case ASAP_SampleFormat.S16LE:
				buffer[buffer_offset++] = sample.LowByte;
				buffer[buffer_offset++] = (sample >> 8).LowByte;
				break;
			case ASAP_SampleFormat.S16BE:
				buffer[buffer_offset++] = (sample >> 8).LowByte;
				buffer[buffer_offset++] = sample.LowByte;
				break;
			}
		}
		STORE_SAMPLE();
		if (ast.extra_pokey_mask != 0) {
			acc_right += ast.extra_pokey.delta_buffer[i] - (acc_right * 3 >> 10);
			sample = acc_right >> 10;
			STORE_SAMPLE();
		}
#endif // FLASH
	}
	if (i == ast.samples) {
		acc_left += ast.base_pokey.delta_buffer[i];
		acc_right += ast.extra_pokey.delta_buffer[i];
	}
	ast.sample_index = i;
	ast.iir_acc_left = acc_left;
	ast.iir_acc_right = acc_right;
#if APOKEYSND
	return buffer_offset;
#else
	return blocks;
#endif
}

bool PokeySound_IsSilent(PokeyState pst)
{
	return (pst.audc1 | pst.audc2 | pst.audc3 | pst.audc4) & 0xf == 0;
}

void PokeySound_Mute(ASAP_State ast, PokeyState pst, int mask)
{
	MUTE_CHANNEL(1, mask & 1 != 0, MuteUser);
	MUTE_CHANNEL(2, mask & 2 != 0, MuteUser);
	MUTE_CHANNEL(3, mask & 4 != 0, MuteUser);
	MUTE_CHANNEL(4, mask & 8 != 0, MuteUser);
}

// TODO: enum
const int NmistReset = 0;
const int NmistOnVBlank = 1;
const int NmistWasVBlank = 2;

macro dGetByte(addr)          (ast.memory[addr])
macro dPutByte(addr, data)    { ast.memory[addr] = (data); }
macro dGetWord(addr)          (dGetByte(addr) + dGetByte((addr) + 1) << 8)

int ASAP_GetByte(ASAP_State ast, int addr)
{
	switch (addr & 0xff1f) {
	case 0xd014:
		return ast.module_info.ntsc ? 0xf : 1;
	case 0xd20a:
	case 0xd21a:
		return PokeySound_GetRandom(ast, addr, ast.cycle);
	case 0xd20e:
		return ast.irqst;
	case 0xd21e:
		if (ast.extra_pokey_mask != 0) {
			// interrupts in the extra POKEY not emulated at the moment
			return 0xff;
		}
		return ast.irqst;
	case 0xd20c:
	case 0xd21c:
	case 0xd20f: // just because some SAP files rely on this
	case 0xd21f:
		return 0xff;
	case 0xd40b:
	case 0xd41b:
		if (ast.scanline_number == 0 && ast.cycle == 13)
			return ast.module_info.ntsc ? 131 : 156;
		return ast.scanline_number >> 1;
	case 0xd40f:
		if (ast.nmist == NmistWasVBlank)
			return 0x5f;
		if (ast.nmist == NmistReset)
			return 0x1f;
		// NmistOnVBlank
		return ast.cycle < 28295 ? 0x1f : 0x5f;
	default:
		return dGetByte(addr);
	}
}

void ASAP_PutByte(ASAP_State ast, int addr, int data)
{
	if (addr >> 8 == 0xd2) {
		if (addr & (ast.extra_pokey_mask + 0xf) == 0xe) {
			ast.irqst |= data ^ 0xff;
			macro SET_TIMER_IRQ(ch) {
				if (data & ast.irqst & ch != 0) {
					if (ast.timer##ch##_cycle == NeverCycle) {
						int t = ast.base_pokey.tick_cycle##ch;
						while (t < ast.cycle)
							t += ast.base_pokey.period_cycles##ch;
						ast.timer##ch##_cycle = t;
						if (ast.nearest_event_cycle > t)
							ast.nearest_event_cycle = t;
					}
				}
				else
					ast.timer##ch##_cycle = NeverCycle;
			}
			SET_TIMER_IRQ(1);
			SET_TIMER_IRQ(2);
			SET_TIMER_IRQ(4);
		}
		else
			PokeySound_PutByte(ast, addr, data);
	}
	else if (addr & 0xff0f == 0xd40a) {
		if (ast.cycle <= ast.next_scanline_cycle - 4)
			ast.cycle = ast.next_scanline_cycle - 4;
		else
			ast.cycle = ast.next_scanline_cycle + 110;
	}
	else if (addr & 0xff0f == 0xd40f) {
		ast.nmist = ast.cycle < 28296 ? NmistOnVBlank : NmistReset;
	}
	else if (addr & 0xff00 == ast.module_info.covox_addr) {
		PokeyState pst;
		addr &= 3;
		if (addr == 0 || addr == 3)
			pst = ast.base_pokey;
		else
			pst = ast.extra_pokey;
		pst.delta_buffer[CYCLE_TO_SAMPLE(ast.cycle)] += (data - ast.covox[addr]) << DeltaShiftCOVOX;
		ast.covox[addr] = data;
	}
	else if (addr & 0xff1f == 0xd01f) {
		data &= 8;
		// NOT data - ast.consol; reverse to the POKEY sound
		int delta = (ast.consol - data) << DeltaShiftGTIA;
		ast.consol = data;
		int sample = CYCLE_TO_SAMPLE(ast.cycle);
		ast.base_pokey.delta_buffer[sample] += delta;
		ast.extra_pokey.delta_buffer[sample] += delta;
	}
	else
		dPutByte(addr, data);
}

macro GetByte(addr)           ((addr) & 0xf900 == 0xd000 ? ASAP_GetByte(ast, addr) : dGetByte(addr))
macro PutByte(addr, data)     { if ((addr) & 0xf900 == 0xd000) ASAP_PutByte(ast, addr, data); else dPutByte(addr, data); }

const int CpuVFlag = 0x40;
const int CpuDFlag = 0x08;
const int CpuIFlag = 0x04;
const int CpuZFlag = 0x02;

// How 6502 registers are stored in this emulator:
// All variables are int, because modern processors (and Java bytecode)
// tend to operate more effectively on these type than narrower ones.
// pc is really an unsigned 16-bit integer.
// a, x, y and s are unsigned 8-bit integers.
// Flags are decomposed into three variables for improved performance.
// c is either 0 or 1.
// nz contains 6502 flags N and Z.
// N is set if (nz >= 0x80). Z is set if ((nz & 0xff) == 0).
// Usually nz is simply assigned the unsigned 8-bit operation result.
// There are just a few operations (ADC in decimal mode, BIT, PLP and RTI)
// where both N and Z may be set. In these cases, N is reflected by the 8th
// (not 7th) bit of nz.
// vdi contains rarely used flags V, D and I, as a combination
// of CpuVFlag, CpuDFlag and CpuIFlag. Other vdi bits are clear.

// "Unofficial" opcodes are those not documented as "legal" 6502 opcodes.
// Their operation has been reverse-engineered on Atari 800XL and Atari 65XE.
// Unofficial opcodes are identical to C64's 6510, except for 0x8b and 0xab.
// The operation of "unstable" opcodes is partially uncertain.
// Explanation is welcome.

// Emulation of POKEY timer interrupts is included.

// Two preprocessor symbols may be used to strip the size of this emulator.
// Define ACPU_NO_DECIMAL to disable emulation of the BCD mode.
// Define ACPU_NO_UNOFFICIAL to disable emulation of unofficial opcodes.

/// Runs 6502 emulation for the specified number of Atari scanlines.
/// Each scanline is 114 cycles of which 9 is taken by ANTIC for memory refresh.
void Cpu_RunScanlines(ASAP_State ast, int scanlines)
{
	// copy registers from ASAP_State to local variables for improved performance
	int pc = ast.cpu_pc;
	int nz = ast.cpu_nz;
	int a = ast.cpu_a;
	int x = ast.cpu_x;
	int y = ast.cpu_y;
	int c = ast.cpu_c;
	int s = ast.cpu_s;
	int vdi = ast.cpu_vdi;
	ast.next_scanline_cycle = 114;
	int next_event_cycle = 114;
	int cycle_limit = 114 * scanlines;
	if (next_event_cycle > ast.timer1_cycle)
		next_event_cycle = ast.timer1_cycle;
	if (next_event_cycle > ast.timer2_cycle)
		next_event_cycle = ast.timer2_cycle;
	if (next_event_cycle > ast.timer4_cycle)
		next_event_cycle = ast.timer4_cycle;
	ast.nearest_event_cycle = next_event_cycle;
	for (;;) {

		macro RMW_GetByte(dest, addr) {
			if ((addr) >> 8 == 0xd2) {
				dest = ASAP_GetByte(ast, addr);
				ast.cycle--;
				ASAP_PutByte(ast, addr, dest);
				ast.cycle++;
			}
			else
				dest = dGetByte(addr);
		}

		macro zGetByte(addr)  (dGetByte((addr) & 0xff))

		macro PEEK()       (dGetByte(pc))
		macro FETCH()      (dGetByte(pc++))

		macro ABSOLUTE()   { addr = FETCH(); addr += FETCH() << 8; }
		macro ABSOLUTE_X() { addr = FETCH(); addr = (addr + FETCH() << 8 + x) & 0xffff; }
		macro ABSOLUTE_Y() { addr = FETCH(); addr = (addr + FETCH() << 8 + y) & 0xffff; }
		macro ZPAGE()      { addr = FETCH(); }
		macro ZPAGE_X()    { addr = (FETCH() + x) & 0xff; }
		macro ZPAGE_Y()    { addr = (FETCH() + y) & 0xff; }
		macro INDIRECT_X() { addr = (FETCH() + x) & 0xff; addr = dGetByte(addr) + (zGetByte(addr + 1) << 8); }
		macro INDIRECT_Y() { addr = FETCH(); addr = (dGetByte(addr) + (zGetByte(addr + 1) << 8) + y) & 0xffff; }
		macro NCYCLES_X()  { if (addr & 0xff < x) ast.cycle++; }
		macro NCYCLES_Y()  { if (addr & 0xff < y) ast.cycle++; }

		macro PL(dest)     { s = (s + 1) & 0xff; dest = dGetByte(0x0100 + s); }
		macro PLP()        { PL(vdi); nz = ((vdi & 0x80) << 1) + (~vdi & CpuZFlag); c = vdi & 1; vdi &= CpuVFlag | CpuDFlag | CpuIFlag; }
		macro PH(data)     { dPutByte(0x0100 + s, data); s = (s - 1) & 0xff; }
		macro PHP(bflag)   { PH(((nz | (nz >> 1)) & 0x80) + vdi + (nz & 0xff == 0 ? CpuZFlag : 0) + c + bflag); }
		macro PHPB0()      { PHP(0x20); }  // push flags with B flag clear (NMI, IRQ)
		macro PHPB1()      { PHP(0x30); }  // push flags with B flag set (PHP, BRK)
		macro PHPC()       { PH(pc >> 8); PH(pc.LowByte); }

#if ACPU_NO_DECIMAL

		macro DO_ADC() {{
			// binary mode
			int tmp = a + data + c;
			vdi = (vdi & (CpuDFlag | CpuIFlag)) + (((~(data ^ a) & (a ^ tmp)) >> 1) & CpuVFlag);
			c = tmp >> 8;
			nz = a = tmp & 0xff;
		}}

		macro DO_SBC() {{
			// binary mode
			int tmp = a - data - 1 + c;
			vdi = (vdi & (CpuDFlag | CpuIFlag)) + ((((data ^ a) & (a ^ tmp)) >> 1) & CpuVFlag);
			c = tmp >= 0 ? 1 : 0;
			nz = a = tmp & 0xff;
		}}

#else // ACPU_NO_DECIMAL

		macro DO_ADC() {{
			int tmp = a + data + c;
			nz = tmp & 0xff;
			if (vdi & CpuDFlag == 0) {
				// binary mode
				vdi = (vdi & (CpuDFlag | CpuIFlag)) + (((~(data ^ a) & (a ^ tmp)) >> 1) & CpuVFlag);
				c = tmp >> 8;
				a = nz;
			}
			else {
				// decimal mode
				int al = (a & 0x0f) + (data & 0x0f) + c;
				if (al >= 10)
					tmp += al < 26 ? 6 : -10;
				nz = ((tmp & 0x80) << 1) + (nz != 0 ? 1 : 0);
				vdi = (vdi & (CpuDFlag | CpuIFlag)) + (((~(data ^ a) & (a ^ tmp)) >> 1) & CpuVFlag);
				if (tmp >= 0xa0) {
					c = 1;
					a = (tmp + 0x60) & 0xff;
				}
				else {
					c = 0;
					a = tmp;
				}
			}
		}}

		macro DO_SBC() {{
			int tmp = a - data - 1 + c;
			int al = (a & 0x0f) - (data & 0x0f) - 1 + c;
			vdi = (vdi & (CpuDFlag | CpuIFlag)) + ((((data ^ a) & (a ^ tmp)) >> 1) & CpuVFlag);
			c = tmp >= 0 ? 1 : 0;
			nz = a = tmp & 0xff;
			if (vdi & CpuDFlag != 0) {
				// decimal mode
				if (al < 0)
					a += (al < -10) ? 10 : -6;
				if (c == 0)
					a = (a - 0x60) & 0xff;
			}
		}}

#endif // ACPU_NO_DECIMAL

		macro LDA()        { nz = a = GetByte(addr); }
		macro LDA_ZP()     { nz = a = dGetByte(addr); }
		macro LDX()        { nz = x = GetByte(addr); }
		macro LDX_ZP()     { nz = x = dGetByte(addr); }
		macro LDY()        { nz = y = GetByte(addr); }
		macro LDY_ZP()     { nz = y = dGetByte(addr); }
		macro LAX()        { nz = x = a = GetByte(addr); }
		macro LAX_ZP()     { nz = x = a = dGetByte(addr); }
		macro STA()        { PutByte(addr, a); }
		macro STA_ZP()     { dPutByte(addr, a); }
		macro STX()        { PutByte(addr, x); }
		macro STX_ZP()     { dPutByte(addr, x); }
		macro STY()        { PutByte(addr, y); }
		macro STY_ZP()     { dPutByte(addr, y); }
		macro SAX()        { data = a & x; PutByte(addr, data); }
		macro SAX_ZP()     { data = a & x; dPutByte(addr, data); }
		macro CMP()        { nz = GetByte(addr); c = a >= nz ? 1 : 0; nz = (a - nz) & 0xff; }
		macro CMP_ZP()     { nz = dGetByte(addr); c = a >= nz ? 1 : 0; nz = (a - nz) & 0xff; }
		macro CPX()        { nz = GetByte(addr); c = x >= nz ? 1 : 0; nz = (x - nz) & 0xff; }
		macro CPX_ZP()     { nz = dGetByte(addr); c = x >= nz ? 1 : 0; nz = (x - nz) & 0xff; }
		macro CPY()        { nz = GetByte(addr); c = y >= nz ? 1 : 0; nz = (y - nz) & 0xff; }
		macro CPY_ZP()     { nz = dGetByte(addr); c = y >= nz ? 1 : 0; nz = (y - nz) & 0xff; }
		macro AND()        { nz = a &= GetByte(addr); }
		macro AND_ZP()     { nz = a &= dGetByte(addr); }
		macro ORA()        { nz = a |= GetByte(addr); }
		macro ORA_ZP()     { nz = a |= dGetByte(addr); }
		macro EOR()        { nz = a ^= GetByte(addr); }
		macro EOR_ZP()     { nz = a ^= dGetByte(addr); }
		macro ADC()        { data = GetByte(addr); DO_ADC(); }
		macro ADC_ZP()     { data = dGetByte(addr); DO_ADC(); }
		macro SBC()        { data = GetByte(addr); DO_SBC(); }
		macro SBC_ZP()     { data = dGetByte(addr); DO_SBC(); }

		macro ASL()        { RMW_GetByte(nz, addr); c = nz >> 7; nz = (nz << 1) & 0xff; PutByte(addr, nz); }
		macro ASL_ZP()     { nz = dGetByte(addr); c = nz >> 7; nz = (nz << 1) & 0xff; dPutByte(addr, nz); }
		macro ROL()        { RMW_GetByte(nz, addr); nz = nz << 1 + c; c = nz >> 8; nz &= 0xff; PutByte(addr, nz); }
		macro ROL_ZP()     { nz = dGetByte(addr); nz = nz << 1 + c; c = nz >> 8; nz &= 0xff; dPutByte(addr, nz); }
		macro LSR()        { RMW_GetByte(nz, addr); c = nz & 1; nz >>= 1; PutByte(addr, nz); }
		macro LSR_ZP()     { nz = dGetByte(addr); c = nz & 1; nz >>= 1; dPutByte(addr, nz); }
		macro ROR()        { RMW_GetByte(nz, addr); nz += c << 8; c = nz & 1; nz >>= 1; PutByte(addr, nz); }
		macro ROR_ZP()     { nz = dGetByte(addr) + c << 8; c = nz & 1; nz >>= 1; dPutByte(addr, nz); }
		macro DEC()        { RMW_GetByte(nz, addr); nz = (nz - 1) & 0xff; PutByte(addr, nz); }
		macro DEC_ZP()     { nz = dGetByte(addr); nz = (nz - 1) & 0xff; dPutByte(addr, nz); }
		macro INC()        { RMW_GetByte(nz, addr); nz = (nz + 1) & 0xff; PutByte(addr, nz); }
		macro INC_ZP()     { nz = dGetByte(addr); nz = (nz + 1) & 0xff; dPutByte(addr, nz); }

		macro ASO()        { ASL(); nz = a |= nz; }
		macro ASO_ZP()     { ASL_ZP(); nz = a |= nz; }
		macro RLA()        { ROL(); nz = a &= nz; }
		macro RLA_ZP()     { ROL_ZP(); nz = a &= nz; }
		macro LSE()        { LSR(); nz = a ^= nz; }
		macro LSE_ZP()     { LSR_ZP(); nz = a ^= nz; }
		macro RRA()        { ROR(); data = nz; DO_ADC(); }
		macro RRA_ZP()     { ROR_ZP(); data = nz; DO_ADC(); }
		macro DCM()        { DEC(); c = a >= nz ? 1 : 0; nz = (a - nz) & 0xff; }
		macro DCM_ZP()     { DEC_ZP(); c = a >= nz ? 1 : 0; nz = (a - nz) & 0xff; }
		macro INS()        { INC(); data = nz; DO_SBC(); }
		macro INS_ZP()     { INC_ZP(); data = nz; DO_SBC(); }

		macro SHX(val,ind) {{
			addr = FETCH();
			int hi = FETCH();
			data = (hi + 1) & val;
			addr += ind;
			if (addr >= 0x100)
				hi = data - 1;
			addr += hi << 8;
			PutByte(addr, data);
		}}

		macro BRANCH(cond) {
			if (cond) {
				addr = PEEK().SByte; // TODO
				pc++;
				addr += pc;
				if ((addr ^ pc) >> 8 != 0)
					ast.cycle++;
				ast.cycle++;
				pc = addr;
				break;
			}
			pc++;
			break;
		}

		macro CHECK_IRQ()  {
			if (vdi & CpuIFlag == 0 && ast.irqst != 0xff) {
				PHPC();
				PHPB0();
				vdi |= CpuIFlag;
				pc = dGetWord(0xfffe);
				ast.cycle += 7;
			}
		}

		int cycle = ast.cycle;
		if (cycle >= ast.nearest_event_cycle) {
			if (cycle >= ast.next_scanline_cycle) {
				if (++ast.scanline_number == (ast.module_info.ntsc ? 262 : 312)) {
					ast.scanline_number = 0;
					ast.nmist = ast.nmist == NmistReset ? NmistOnVBlank : NmistWasVBlank;
				}
				if (ast.cycle - ast.next_scanline_cycle < 50) // not WSYNC
					ast.cycle = cycle += 9;
				ast.next_scanline_cycle += 114;
				if (--scanlines <= 0)
					break;
			}
			next_event_cycle = ast.next_scanline_cycle;
			macro CHECK_TIMER_IRQ(ch) {
				if (cycle >= ast.timer##ch##_cycle) {
					ast.irqst &= ~ch;
					ast.timer##ch##_cycle = NeverCycle;
				}
				else if (next_event_cycle > ast.timer##ch##_cycle)
					next_event_cycle = ast.timer##ch##_cycle;
			}
			CHECK_TIMER_IRQ(1);
			CHECK_TIMER_IRQ(2);
			CHECK_TIMER_IRQ(4);
			ast.nearest_event_cycle = next_event_cycle;
			CHECK_IRQ();
		}

#if ASAPSCAN
		if (cpu_trace != 0)
			trace_cpu(ast, pc, a, x, y, s, nz, vdi, c);
#endif
		int data = FETCH();
		const int[256] opcode_cycles = {
		//	0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F 
			7, 6, 2, 8, 3, 3, 5, 5, 3, 2, 2, 2, 4, 4, 6, 6, // 0x
			2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7, // 1x 
			6, 6, 2, 8, 3, 3, 5, 5, 4, 2, 2, 2, 4, 4, 6, 6, // 2x
			2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7, // 3x
			6, 6, 2, 8, 3, 3, 5, 5, 3, 2, 2, 2, 3, 4, 6, 6, // 4x
			2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7, // 5x
			6, 6, 2, 8, 3, 3, 5, 5, 4, 2, 2, 2, 5, 4, 6, 6, // 6x
			2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7, // 7x
			2, 6, 2, 6, 3, 3, 3, 3, 2, 2, 2, 2, 4, 4, 4, 4, // 8x
			2, 6, 2, 6, 4, 4, 4, 4, 2, 5, 2, 5, 5, 5, 5, 5, // 9x
			2, 6, 2, 6, 3, 3, 3, 3, 2, 2, 2, 2, 4, 4, 4, 4, // Ax
			2, 5, 2, 5, 4, 4, 4, 4, 2, 4, 2, 4, 4, 4, 4, 4, // Bx
			2, 6, 2, 8, 3, 3, 5, 5, 2, 2, 2, 2, 4, 4, 6, 6, // Cx
			2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7, // Dx
			2, 6, 2, 8, 3, 3, 5, 5, 2, 2, 2, 2, 4, 4, 6, 6, // Ex
			2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7  // Fx
		};
		ast.cycle += opcode_cycles[data];
		int addr;

		switch (data) {
		case 0x00: // BRK
			pc++;
			PHPC();
			PHPB1();
			vdi |= CpuIFlag;
			pc = dGetWord(0xfffe);
			break;
		case 0x01: // ORA (ab,x)
			INDIRECT_X();
			ORA();
			break;
		case 0x02: // CIM [unofficial]
		case 0x12:
		case 0x22:
		case 0x32:
		case 0x42:
		case 0x52:
		case 0x62:
		case 0x72:
		case 0x92:
		case 0xb2:
		case 0xd2:
		case 0xf2:
			ast.scanline_number = (ast.scanline_number + scanlines - 1) % (ast.module_info.ntsc ? 262 : 312);
			scanlines = 1;
			ast.cycle = cycle_limit;
			break;
		case 0x05: // ORA ab
			ZPAGE();
			ORA_ZP();
			break;
		case 0x06: // ASL ab
			ZPAGE();
			ASL_ZP();
			break;
		case 0x08: // PHP
			PHPB1();
			break;
		case 0x09: // ORA #ab
			nz = a |= FETCH();
			break;
		case 0x0a: // ASL
			c = a >> 7;
			nz = a = (a << 1) & 0xff;
			break;
		case 0x0d: // ORA abcd
			ABSOLUTE();
			ORA();
			break;
		case 0x0e: // ASL abcd
			ABSOLUTE();
			ASL();
			break;
		case 0x10: // BPL
			BRANCH(nz < 0x80);
		case 0x11: // ORA (ab),y
			INDIRECT_Y();
			NCYCLES_Y();
			ORA();
			break;
		case 0x15: // ORA ab,x
			ZPAGE_X();
			ORA_ZP();
			break;
		case 0x16: // ASL ab,x
			ZPAGE_X();
			ASL_ZP();
			break;
		case 0x18: // CLC
			c = 0;
			break;
		case 0x19: // ORA abcd,y
			ABSOLUTE_Y();
			NCYCLES_Y();
			ORA();
			break;
		case 0x1d: // ORA abcd,x
			ABSOLUTE_X();
			NCYCLES_X();
			ORA();
			break;
		case 0x1e: // ASL abcd,x
			ABSOLUTE_X();
			ASL();
			break;
		case 0x20: // JSR abcd
			addr = FETCH();
			PHPC();
			pc = addr + PEEK() << 8;
			break;
		case 0x21: // AND (ab,x)
			INDIRECT_X();
			AND();
			break;
		case 0x24: // BIT ab
			ZPAGE();
			nz = dGetByte(addr);
			vdi = (vdi & (CpuDFlag | CpuIFlag)) + (nz & CpuVFlag);
			nz = ((nz & 0x80) << 1) + (nz & a);
			break;
		case 0x25: // AND ab
			ZPAGE();
			AND_ZP();
			break;
		case 0x26: // ROL ab
			ZPAGE();
			ROL_ZP();
			break;
		case 0x28: // PLP
			PLP();
			CHECK_IRQ();
			break;
		case 0x29: // AND #ab
			nz = a &= FETCH();
			break;
		case 0x2a: // ROL
			a = (a << 1) + c;
			c = a >> 8;
			nz = a &= 0xff;
			break;
		case 0x2c: // BIT abcd
			ABSOLUTE();
			nz = GetByte(addr);
			vdi = (vdi & (CpuDFlag | CpuIFlag)) + (nz & CpuVFlag);
			nz = ((nz & 0x80) << 1) + (nz & a);
			break;
		case 0x2d: // AND abcd
			ABSOLUTE();
			AND();
			break;
		case 0x2e: // ROL abcd
			ABSOLUTE();
			ROL();
			break;
		case 0x30: // BMI
			BRANCH(nz >= 0x80);
		case 0x31: // AND (ab),y
			INDIRECT_Y();
			NCYCLES_Y();
			AND();
			break;
		case 0x35: // AND ab,x
			ZPAGE_X();
			AND_ZP();
			break;
		case 0x36: // ROL ab,x
			ZPAGE_X();
			ROL_ZP();
			break;
		case 0x38: // SEC
			c = 1;
			break;
		case 0x39: // AND abcd,y
			ABSOLUTE_Y();
			NCYCLES_Y();
			AND();
			break;
		case 0x3d: // AND abcd,x
			ABSOLUTE_X();
			NCYCLES_X();
			AND();
			break;
		case 0x3e: // ROL abcd,x
			ABSOLUTE_X();
			ROL();
			break;
		case 0x40: // RTI
			PLP();
			PL(pc);
			PL(addr);
			pc += addr << 8;
			CHECK_IRQ();
			break;
		case 0x41: // EOR (ab,x)
			INDIRECT_X();
			EOR();
			break;
		case 0x45: // EOR ab
			ZPAGE();
			EOR_ZP();
			break;
		case 0x46: // LSR ab
			ZPAGE();
			LSR_ZP();
			break;
		case 0x48: // PHA
			PH(a);
			break;
		case 0x49: // EOR #ab
			nz = a ^= FETCH();
			break;
		case 0x4a: // LSR
			c = a & 1;
			nz = a >>= 1;
			break;
		case 0x4c: // JMP abcd
			addr = FETCH();
			pc = addr + PEEK() << 8;
			break;
		case 0x4d: // EOR abcd
			ABSOLUTE();
			EOR();
			break;
		case 0x4e: // LSR abcd
			ABSOLUTE();
			LSR();
			break;
		case 0x50: // BVC
			BRANCH(vdi & CpuVFlag == 0);
		case 0x51: // EOR (ab),y
			INDIRECT_Y();
			NCYCLES_Y();
			EOR();
			break;
		case 0x55: // EOR ab,x
			ZPAGE_X();
			EOR_ZP();
			break;
		case 0x56: // LSR ab,x
			ZPAGE_X();
			LSR_ZP();
			break;
		case 0x58: // CLI
			vdi &= CpuVFlag | CpuDFlag;
			CHECK_IRQ();
			break;
		case 0x59: // EOR abcd,y
			ABSOLUTE_Y();
			NCYCLES_Y();
			EOR();
			break;
		case 0x5d: // EOR abcd,x
			ABSOLUTE_X();
			NCYCLES_X();
			EOR();
			break;
		case 0x5e: // LSR abcd,x
			ABSOLUTE_X();
			LSR();
			break;
		case 0x60: // RTS
			PL(pc);
			PL(addr);
			pc += (addr << 8) + 1;
			break;
		case 0x61: // ADC (ab,x)
			INDIRECT_X();
			ADC();
			break;
		case 0x65: // ADC ab
			ZPAGE();
			ADC_ZP();
			break;
		case 0x66: // ROR ab
			ZPAGE();
			ROR_ZP();
			break;
		case 0x68: // PLA
			PL(a);
			nz = a;
			break;
		case 0x69: // ADC #ab
			data = FETCH();
			DO_ADC();
			break;
		case 0x6a: // ROR
			nz = (c << 7) + (a >> 1);
			c = a & 1;
			a = nz;
			break;
		case 0x6c: // JMP (abcd)
			ABSOLUTE();
			if (addr & 0xff == 0xff)
				pc = dGetByte(addr - 0xff) << 8 + dGetByte(addr);
			else
				pc = dGetWord(addr);
			break;
		case 0x6d: // ADC abcd
			ABSOLUTE();
			ADC();
			break;
		case 0x6e: // ROR abcd
			ABSOLUTE();
			ROR();
			break;
		case 0x70: // BVS
			BRANCH(vdi & CpuVFlag != 0);
		case 0x71: // ADC (ab),y
			INDIRECT_Y();
			NCYCLES_Y();
			ADC();
			break;
		case 0x75: // ADC ab,x
			ZPAGE_X();
			ADC_ZP();
			break;
		case 0x76: // ROR ab,x
			ZPAGE_X();
			ROR_ZP();
			break;
		case 0x78: // SEI
			vdi |= CpuIFlag;
			break;
		case 0x79: // ADC abcd,y
			ABSOLUTE_Y();
			NCYCLES_Y();
			ADC();
			break;
		case 0x7d: // ADC abcd,x
			ABSOLUTE_X();
			NCYCLES_X();
			ADC();
			break;
		case 0x7e: // ROR abcd,x
			ABSOLUTE_X();
			ROR();
			break;
		case 0x81: // STA (ab,x)
			INDIRECT_X();
			STA();
			break;
		case 0x84: // STY ab
			ZPAGE();
			STY_ZP();
			break;
		case 0x85: // STA ab
			ZPAGE();
			STA_ZP();
			break;
		case 0x86: // STX ab
			ZPAGE();
			STX_ZP();
			break;
		case 0x88: // DEY
			nz = y = (y - 1) & 0xff;
			break;
		case 0x8a: // TXA
			nz = a = x;
			break;
		case 0x8c: // STY abcd
			ABSOLUTE();
			STY();
			break;
		case 0x8d: // STA abcd
			ABSOLUTE();
			STA();
			break;
		case 0x8e: // STX abcd
			ABSOLUTE();
			STX();
			break;
		case 0x90: // BCC
			BRANCH(c == 0);
		case 0x91: // STA (ab),y
			INDIRECT_Y();
			STA();
			break;
		case 0x94: // STY ab,x
			ZPAGE_X();
			STY_ZP();
			break;
		case 0x95: // STA ab,x
			ZPAGE_X();
			STA_ZP();
			break;
		case 0x96: // STX ab,y
			ZPAGE_Y();
			STX_ZP();
			break;
		case 0x98: // TYA
			nz = a = y;
			break;
		case 0x99: // STA abcd,y
			ABSOLUTE_Y();
			STA();
			break;
		case 0x9a: // TXS
			s = x;
			break;
		case 0x9d: // STA abcd,x
			ABSOLUTE_X();
			STA();
			break;
		case 0xa0: // LDY #ab
			nz = y = FETCH();
			break;
		case 0xa1: // LDA (ab,x)
			INDIRECT_X();
			LDA();
			break;
		case 0xa2: // LDX #ab
			nz = x = FETCH();
			break;
		case 0xa4: // LDY ab
			ZPAGE();
			LDY_ZP();
			break;
		case 0xa5: // LDA ab
			ZPAGE();
			LDA_ZP();
			break;
		case 0xa6: // LDX ab
			ZPAGE();
			LDX_ZP();
			break;
		case 0xa8: // TAY
			nz = y = a;
			break;
		case 0xa9: // LDA #ab
			nz = a = FETCH();
			break;
		case 0xaa: // TAX
			nz = x = a;
			break;
		case 0xac: // LDY abcd
			ABSOLUTE();
			LDY();
			break;
		case 0xad: // LDA abcd
			ABSOLUTE();
			LDA();
			break;
		case 0xae: // LDX abcd
			ABSOLUTE();
			LDX();
			break;
		case 0xb0: // BCS
			BRANCH(c != 0);
		case 0xb1: // LDA (ab),y
			INDIRECT_Y();
			NCYCLES_Y();
			LDA();
			break;
		case 0xb4: // LDY ab,x
			ZPAGE_X();
			LDY_ZP();
			break;
		case 0xb5: // LDA ab,x
			ZPAGE_X();
			LDA_ZP();
			break;
		case 0xb6: // LDX ab,y
			ZPAGE_Y();
			LDX_ZP();
			break;
		case 0xb8: // CLV
			vdi &= CpuDFlag | CpuIFlag;
			break;
		case 0xb9: // LDA abcd,y
			ABSOLUTE_Y();
			NCYCLES_Y();
			LDA();
			break;
		case 0xba: // TSX
			nz = x = s;
			break;
		case 0xbc: // LDY abcd,x
			ABSOLUTE_X();
			NCYCLES_X();
			LDY();
			break;
		case 0xbd: // LDA abcd,x
			ABSOLUTE_X();
			NCYCLES_X();
			LDA();
			break;
		case 0xbe: // LDX abcd,y
			ABSOLUTE_Y();
			NCYCLES_Y();
			LDX();
			break;
		case 0xc0: // CPY #ab
			nz = FETCH();
			c = y >= nz ? 1 : 0;
			nz = (y - nz) & 0xff;
			break;
		case 0xc1: // CMP (ab,x)
			INDIRECT_X();
			CMP();
			break;
		case 0xc4: // CPY ab
			ZPAGE();
			CPY_ZP();
			break;
		case 0xc5: // CMP ab
			ZPAGE();
			CMP_ZP();
			break;
		case 0xc6: // DEC ab
			ZPAGE();
			DEC_ZP();
			break;
		case 0xc8: // INY
			nz = y = (y + 1) & 0xff;
			break;
		case 0xc9: // CMP #ab
			nz = FETCH();
			c = a >= nz ? 1 : 0;
			nz = (a - nz) & 0xff;
			break;
		case 0xca: // DEX
			nz = x = (x - 1) & 0xff;
			break;
		case 0xcc: // CPY abcd
			ABSOLUTE();
			CPY();
			break;
		case 0xcd: // CMP abcd
			ABSOLUTE();
			CMP();
			break;
		case 0xce: // DEC abcd
			ABSOLUTE();
			DEC();
			break;
		case 0xd0: // BNE
			BRANCH(nz & 0xff != 0);
		case 0xd1: // CMP (ab),y
			INDIRECT_Y();
			NCYCLES_Y();
			CMP();
			break;
		case 0xd5: // CMP ab,x
			ZPAGE_X();
			CMP_ZP();
			break;
		case 0xd6: // DEC ab,x
			ZPAGE_X();
			DEC_ZP();
			break;
		case 0xd8: // CLD
			vdi &= CpuVFlag | CpuIFlag;
			break;
		case 0xd9: // CMP abcd,y
			ABSOLUTE_Y();
			NCYCLES_Y();
			CMP();
			break;
		case 0xdd: // CMP abcd,x
			ABSOLUTE_X();
			NCYCLES_X();
			CMP();
			break;
		case 0xde: // DEC abcd,x
			ABSOLUTE_X();
			DEC();
			break;
		case 0xe0: // CPX #ab
			nz = FETCH();
			c = x >= nz ? 1 : 0;
			nz = (x - nz) & 0xff;
			break;
		case 0xe1: // SBC (ab,x)
			INDIRECT_X();
			SBC();
			break;
		case 0xe4: // CPX ab
			ZPAGE();
			CPX_ZP();
			break;
		case 0xe5: // SBC ab
			ZPAGE();
			SBC_ZP();
			break;
		case 0xe6: // INC ab
			ZPAGE();
			INC_ZP();
			break;
		case 0xe8: // INX
			nz = x = (x + 1) & 0xff;
			break;
		case 0xe9: // SBC #ab
		case 0xeb: // SBC #ab [unofficial]
			data = FETCH();
			DO_SBC();
			break;
		case 0xea: // NOP
		case 0x1a: // NOP [unofficial]
		case 0x3a:
		case 0x5a:
		case 0x7a:
		case 0xda:
		case 0xfa:
			break;
		case 0xec: // CPX abcd
			ABSOLUTE();
			CPX();
			break;
		case 0xed: // SBC abcd
			ABSOLUTE();
			SBC();
			break;
		case 0xee: // INC abcd
			ABSOLUTE();
			INC();
			break;
		case 0xf0: // BEQ
			BRANCH(nz & 0xff == 0);
		case 0xf1: // SBC (ab),y
			INDIRECT_Y();
			NCYCLES_Y();
			SBC();
			break;
		case 0xf5: // SBC ab,x
			ZPAGE_X();
			SBC_ZP();
			break;
		case 0xf6: // INC ab,x
			ZPAGE_X();
			INC_ZP();
			break;
		case 0xf8: // SED
			vdi |= CpuDFlag;
			break;
		case 0xf9: // SBC abcd,y
			ABSOLUTE_Y();
			NCYCLES_Y();
			SBC();
			break;
		case 0xfd: // SBC abcd,x
			ABSOLUTE_X();
			NCYCLES_X();
			SBC();
			break;
		case 0xfe: // INC abcd,x
			ABSOLUTE_X();
			INC();
			break;

#if !ACPU_NO_UNOFFICIAL
		case 0x03: // ASO (ab,x) [unofficial]
			INDIRECT_X();
			ASO();
			break;
		case 0x04: // NOP ab [unofficial]
		case 0x44:
		case 0x64:
		case 0x14: // NOP ab,x [unofficial]
		case 0x34:
		case 0x54:
		case 0x74:
		case 0xd4:
		case 0xf4:
		case 0x80: // NOP #ab [unofficial]
		case 0x82:
		case 0x89:
		case 0xc2:
		case 0xe2:
			pc++;
			break;
		case 0x07: // ASO ab [unofficial]
			ZPAGE();
			ASO_ZP();
			break;
		case 0x0b: // ANC #ab [unofficial]
		case 0x2b:
			nz = a &= FETCH();
			c = nz >> 7;
			break;
		case 0x0c: // NOP abcd [unofficial]
			pc += 2;
			break;
		case 0x0f: // ASO abcd [unofficial]
			ABSOLUTE();
			ASO();
			break;
		case 0x13: // ASO (ab),y [unofficial]
			INDIRECT_Y();
			ASO();
			break;
		case 0x17: // ASO ab,x [unofficial]
			ZPAGE_X();
			ASO_ZP();
			break;
		case 0x1b: // ASO abcd,y [unofficial]
			ABSOLUTE_Y();
			ASO();
			break;
		case 0x1c: // NOP abcd,x [unofficial]
		case 0x3c:
		case 0x5c:
		case 0x7c:
		case 0xdc:
		case 0xfc:
			if (FETCH() + x >= 0x100)
				ast.cycle++;
			pc++;
			break;
		case 0x1f: // ASO abcd,x [unofficial]
			ABSOLUTE_X();
			ASO();
			break;
		case 0x23: // RLA (ab,x) [unofficial]
			INDIRECT_X();
			RLA();
			break;
		case 0x27: // RLA ab [unofficial]
			ZPAGE();
			RLA_ZP();
			break;
		case 0x2f: // RLA abcd [unofficial]
			ABSOLUTE();
			RLA();
			break;
		case 0x33: // RLA (ab),y [unofficial]
			INDIRECT_Y();
			RLA();
			break;
		case 0x37: // RLA ab,x [unofficial]
			ZPAGE_X();
			RLA_ZP();
			break;
		case 0x3b: // RLA abcd,y [unofficial]
			ABSOLUTE_Y();
			RLA();
			break;
		case 0x3f: // RLA abcd,x [unofficial]
			ABSOLUTE_X();
			RLA();
			break;
		case 0x43: // LSE (ab,x) [unofficial]
			INDIRECT_X();
			LSE();
			break;
		case 0x47: // LSE ab [unofficial]
			ZPAGE();
			LSE_ZP();
			break;
		case 0x4b: // ALR #ab [unofficial]
			a &= FETCH();
			c = a & 1;
			nz = a >>= 1;
			break;
		case 0x4f: // LSE abcd [unofficial]
			ABSOLUTE();
			LSE();
			break;
		case 0x53: // LSE (ab),y [unofficial]
			INDIRECT_Y();
			LSE();
			break;
		case 0x57: // LSE ab,x [unofficial]
			ZPAGE_X();
			LSE_ZP();
			break;
		case 0x5b: // LSE abcd,y [unofficial]
			ABSOLUTE_Y();
			LSE();
			break;
		case 0x5f: // LSE abcd,x [unofficial]
			ABSOLUTE_X();
			LSE();
			break;
		case 0x63: // RRA (ab,x) [unofficial]
			INDIRECT_X();
			RRA();
			break;
		case 0x67: // RRA ab [unofficial]
			ZPAGE();
			RRA_ZP();
			break;
		case 0x6b: // ARR #ab [unofficial]
			data = a & FETCH();
			nz = a = (data >> 1) + (c << 7);
			vdi = (vdi & (CpuDFlag | CpuIFlag)) + ((a ^ data) & CpuVFlag);
#if ACPU_NO_DECIMAL
			c = data >> 7;
#else
			if (vdi & CpuDFlag == 0)
				c = data >> 7;
			else {
				if (data & 0xf >= 5)
					a = (a & 0xf0) + ((a + 6) & 0xf);
				if (data >= 0x50) {
					a = (a + 0x60) & 0xff;
					c = 1;
				}
				else
					c = 0;
			}
#endif
			break;
		case 0x6f: // RRA abcd [unofficial]
			ABSOLUTE();
			RRA();
			break;
		case 0x73: // RRA (ab),y [unofficial]
			INDIRECT_Y();
			RRA();
			break;
		case 0x77: // RRA ab,x [unofficial]
			ZPAGE_X();
			RRA_ZP();
			break;
		case 0x7b: // RRA abcd,y [unofficial]
			ABSOLUTE_Y();
			RRA();
			break;
		case 0x7f: // RRA abcd,x [unofficial]
			ABSOLUTE_X();
			RRA();
			break;
		case 0x83: // SAX (ab,x) [unofficial]
			INDIRECT_X();
			SAX();
			break;
		case 0x87: // SAX ab [unofficial]
			ZPAGE();
			SAX_ZP();
			break;
		case 0x8b: // ANE #ab [unofficial]
			data = FETCH();
			a &= (data | 0xef) & x;
			nz = a & data;
			break;
		case 0x8f: // SAX abcd [unofficial]
			ABSOLUTE();
			SAX();
			break;
		case 0x93: // SHA (ab),y [unofficial, unstable]
			{
				addr = FETCH();
				int hi = zGetByte(addr + 1);
				addr = dGetByte(addr);
				data = (hi + 1) & a & x;
				addr += y;
				if (addr >= 0x100)
					hi = data - 1;
				addr += hi << 8;
				PutByte(addr, data);
			}
			break;
		case 0x97: // SAX ab,y [unofficial]
			ZPAGE_Y();
			SAX_ZP();
			break;
		case 0x9b: // SHS abcd,y [unofficial, unstable]
			// S seems to be stable, only memory values vary
			s = a & x;
			SHX(s, y);
			break;
		case 0x9c: // SHY abcd,x [unofficial]
			SHX(y, x);
			break;
		case 0x9e: // SHX abcd,y [unofficial]
			SHX(x, y);
			break;
		case 0x9f: // SHA abcd,y [unofficial, unstable]
			SHX(a & x, y);
			break;
		case 0xa3: // LAX (ab,x) [unofficial]
			INDIRECT_X();
			LAX();
			break;
		case 0xa7: // LAX ab [unofficial]
			ZPAGE();
			LAX_ZP();
			break;
		case 0xab: // ANX #ab [unofficial]
			nz = x = a &= FETCH();
			break;
		case 0xaf: // LAX abcd [unofficial]
			ABSOLUTE();
			LAX();
			break;
		case 0xb3: // LAX (ab),y [unofficial]
			INDIRECT_Y();
			NCYCLES_Y();
			LAX();
			break;
		case 0xb7: // LAX ab,y [unofficial]
			ZPAGE_Y();
			LAX_ZP();
			break;
		case 0xbb: // LAS abcd,y [unofficial, unstable]
			// only Z is unstable
			ABSOLUTE_Y();
			NCYCLES_Y();
			nz = x = a = s &= GetByte(addr);
			break;
		case 0xbf: // LAX abcd,y [unofficial]
			ABSOLUTE_Y();
			NCYCLES_Y();
			LAX();
			break;
		case 0xc3: // DCM (ab,x) [unofficial]
			INDIRECT_X();
			DCM();
			break;
		case 0xc7: // DCM ab [unofficial]
			ZPAGE();
			DCM_ZP();
			break;
		case 0xcb: // SBX #ab [unofficial]
			nz = FETCH();
			x &= a;
			c = x >= nz ? 1 : 0;
			nz = x = (x - nz) & 0xff;
			break;
		case 0xcf: // DCM abcd [unofficial]
			ABSOLUTE();
			DCM();
			break;
		case 0xd3: // DCM (ab),y [unofficial]
			INDIRECT_Y();
			DCM();
			break;
		case 0xd7: // DCM ab,x [unofficial]
			ZPAGE_X();
			DCM_ZP();
			break;
		case 0xdb: // DCM abcd,y [unofficial]
			ABSOLUTE_Y();
			DCM();
			break;
		case 0xdf: // DCM abcd,x [unofficial]
			ABSOLUTE_X();
			DCM();
			break;
		case 0xe3: // INS (ab,x) [unofficial]
			INDIRECT_X();
			INS();
			break;
		case 0xe7: // INS ab [unofficial]
			ZPAGE();
			INS_ZP();
			break;
		case 0xef: // INS abcd [unofficial]
			ABSOLUTE();
			INS();
			break;
		case 0xf3: // INS (ab),y [unofficial]
			INDIRECT_Y();
			INS();
			break;
		case 0xf7: // INS ab,x [unofficial]
			ZPAGE_X();
			INS_ZP();
			break;
		case 0xfb: // INS abcd,y [unofficial]
			ABSOLUTE_Y();
			INS();
			break;
		case 0xff: // INS abcd,x [unofficial]
			ABSOLUTE_X();
			INS();
			break;
#endif // ACPU_NO_UNOFFICIAL
		}
	}
	ast.cpu_pc = pc;
	ast.cpu_nz = nz;
	ast.cpu_a = a;
	ast.cpu_x = x;
	ast.cpu_y = y;
	ast.cpu_c = c;
	ast.cpu_s = s;
	ast.cpu_vdi = vdi;
	ast.cycle -= cycle_limit;
	if (ast.timer1_cycle != NeverCycle)
		ast.timer1_cycle -= cycle_limit;
	if (ast.timer2_cycle != NeverCycle)
		ast.timer2_cycle -= cycle_limit;
	if (ast.timer4_cycle != NeverCycle)
		ast.timer4_cycle -= cycle_limit;
}
