// asap.ci - emulation engine
//
// Copyright (C) 2010-2011  Piotr Fusik
//
// This file is part of ASAP (Another Slight Atari Player),
// see http://asap.sourceforge.net
//
// ASAP is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published
// by the Free Software Foundation; either version 2 of the License,
// or (at your option) any later version.
//
// ASAP is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty
// of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with ASAP; if not, write to the Free Software Foundation, Inc.,
// 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

/// Format of output samples.
public enum ASAPSampleFormat
{
	/// Unsigned 8-bit.
	U8,
	/// Signed 16-bit little-endian.
	S16LE,
	/// Signed 16-bit big-endian.
	S16BE
}

enum NmiStatus
{
	Reset,
	OnVBlank,
	WasVBlank
}

/// 8-bit Atari chip music emulator.
/// This class performs no I/O operations - all music data must be passed in byte arrays.
public class ASAP
{
	/// Output sample rate.
	public const int SampleRate = 44100;

	int Cycle;
	int NextEventCycle;
	const int NeverCycle = 0x800000;

	byte[65536] Memory;

	Cpu6502() Cpu;

	// ANTIC:
	int NextScanlineCycle;
	NmiStatus Nmist;

	// GTIA:
	int Consol;

	// COVOX:
	byte[4] Covox;

	// POKEYs:
	PokeyPair() Pokeys;

	/// Information about the loaded module.
	public ASAPInfo() ModuleInfo;

	int NextPlayerCycle;
	int TmcPerFrame;
	int TmcPerFrameCounter;
	int CurrentSong;
	int CurrentDuration;

	/// Current playback position in blocks.
	/// A block is one sample or a pair of samples for stereo.
	public int BlocksPlayed;

	int SilenceCycles;
	int SilenceCyclesCounter;

	int PeekHardware(int addr)
	{
		switch (addr & 0xff1f) {
		case 0xd014:
			return ModuleInfo.Ntsc ? 0xf : 1;
		case 0xd20a:
		case 0xd21a:
			return Pokeys.GetRandom(addr, Cycle);
		case 0xd20e:
			return Pokeys.Irqst;
		case 0xd21e:
			if (Pokeys.ExtraPokeyMask != 0) {
				// interrupts in the extra POKEY not emulated at the moment
				return 0xff;
			}
			return Pokeys.Irqst;
		case 0xd20c:
		case 0xd21c:
		case 0xd20f: // just because some SAP files rely on this
		case 0xd21f:
			return 0xff;
		case 0xd40b:
		case 0xd41b:
			if (Cycle == 13)
				return ModuleInfo.Ntsc ? 131 : 156;
			return Cycle / 228;
		case 0xd40f:
			switch (Nmist) {
			case NmiStatus.Reset:
				return 0x1f;
			case NmiStatus.WasVBlank:
				return 0x5f;
			case NmiStatus.OnVBlank:
			default: // shut up compilers
				return Cycle < 28295 ? 0x1f : 0x5f;
			}
		default:
			return Memory[addr];
		}
	}

	void PokeHardware(int addr, int data)
	{
		if (addr >> 8 == 0xd2) {
			if (addr & (Pokeys.ExtraPokeyMask + 0xf) == 0xe) {
				Pokeys.Irqst |= data ^ 0xff;
				macro SET_TIMER_IRQ(ch) {
					if ((data & Pokeys.Irqst & ch) != 0) {
						if (Pokeys.Timer##ch##Cycle == NeverCycle) {
							int t = Pokeys.BasePokey.TickCycle##ch;
							while (t < Cycle)
								t += Pokeys.BasePokey.PeriodCycles##ch;
							Pokeys.Timer##ch##Cycle = t;
							if (NextEventCycle > t)
								NextEventCycle = t;
						}
					}
					else
						Pokeys.Timer##ch##Cycle = NeverCycle;
				}
				SET_TIMER_IRQ(1);
				SET_TIMER_IRQ(2);
				SET_TIMER_IRQ(4);
			}
			else
				Pokeys.Poke(addr, data, Cycle);
		}
		else if ((addr & 0xff0f) == 0xd40a) {
			int x = Cycle % 114;
			Cycle += (x <= 110 ? 110 + 114 : 110) - x;
		}
		else if ((addr & 0xff0f) == 0xd40f) {
			Nmist = Cycle < 28296 ? NmiStatus.OnVBlank : NmiStatus.Reset;
		}
		else if ((addr & 0xff00) == ModuleInfo.CovoxAddr) {
			Pokey pokey;
			addr &= 3;
			if (addr == 0 || addr == 3)
				pokey = Pokeys.BasePokey;
			else
				pokey = Pokeys.ExtraPokey;
			const int DeltaShiftCOVOX = 17;
			pokey.AddDelta(Pokeys, Cycle, (data - Covox[addr]) << DeltaShiftCOVOX);
			Covox[addr] = data;
		}
		else if ((addr & 0xff1f) == 0xd01f) {
			data &= 8;
			const int DeltaShiftGTIA = 20;
			// NOT data - ast.consol; reverse to the POKEY sound
			int delta = (Consol - data) << DeltaShiftGTIA;
			Pokeys.BasePokey.AddDelta(Pokeys, Cycle, delta);
			Pokeys.ExtraPokey.AddDelta(Pokeys, Cycle, delta);
			Consol = data;
		}
		else
			Memory[addr] = data;
	}

	void Call6502(int addr)
	{
		const int codeAddr = 0xd200;
		Memory[codeAddr] = 0x20; // JSR
		Memory[codeAddr + 1] = addr.LowByte;
		Memory[codeAddr + 2] = addr >> 8;
		Memory[codeAddr + 3] = 0xd2; // escape
		Cpu.PC = codeAddr;
	}

	void Call6502Player()
	{
		int player = ModuleInfo.Player;
		switch (ModuleInfo.Type) {
		case ASAPModuleType.SAPB:
			Call6502(player);
			break;
		case ASAPModuleType.SAPC:
	#if !ASAP_ONLY_SAP
		case ASAPModuleType.CMC:
		case ASAPModuleType.CM3:
		case ASAPModuleType.CMR:
		case ASAPModuleType.CMS:
	#endif
			Call6502(player + 6);
			break;
		case ASAPModuleType.SAPD:
			if (player >= 0) {
				macro PH(x) { Memory[0x100 + Cpu.S] = x; Cpu.S = (Cpu.S - 1) & 0xff; }
				PH(Cpu.PC >> 8);
				PH(Cpu.PC.LowByte);
				const int codeAddr = 0xd200;
				Memory[codeAddr] = 0x08; // PHP
				Memory[codeAddr + 1] = 0x48; // PHA
				Memory[codeAddr + 2] = 0x8a; // TXA
				Memory[codeAddr + 3] = 0x48; // PHA
				Memory[codeAddr + 4] = 0x8a; // TYA
				Memory[codeAddr + 5]= 0x48; // PHA
				Memory[codeAddr + 6] = 0x20; // JSR
				Memory[codeAddr + 7] = player.LowByte;
				Memory[codeAddr + 8] = player >> 8;
				Memory[codeAddr + 9] = 0x68; // PLA
				Memory[codeAddr + 10] = 0xa8; // TAY
				Memory[codeAddr + 11] = 0x68; // PLA
				Memory[codeAddr + 12] = 0xaa; // TAX
				Memory[codeAddr + 13] = 0x68; // PLA
				Memory[codeAddr + 14] = 0x40; // RTI
				Cpu.PC = codeAddr;
			}
			break;
		case ASAPModuleType.SAPS:
			int i = Memory[0x45] - 1;
			Memory[0x45] = i.LowByte;
			if (i == 0)
				Memory[0xb07b] = (Memory[0xb07b] + 1).LowByte;
			break;
	#if !ASAP_ONLY_SAP
		case ASAPModuleType.DLT:
			Call6502(player + 0x103);
			break;
		case ASAPModuleType.MPT:
		case ASAPModuleType.RMT:
		case ASAPModuleType.TM2:
			Call6502(player + 3);
			break;
		case ASAPModuleType.TMC:
			if (--TmcPerFrameCounter <= 0) {
				TmcPerFrameCounter = TmcPerFrame;
				Call6502(player + 3);
			}
			else
				Call6502(player + 6);
			break;
	#endif
		}
	}

	void HandleEvent()
	{
		int cycle = Cycle;
		if (cycle >= NextScanlineCycle) {
			if (cycle - NextScanlineCycle < 50) // not WSYNC
				Cycle = cycle += 9;
			NextScanlineCycle += 114;
			if (cycle >= NextPlayerCycle) {
				Call6502Player();
				NextPlayerCycle += 114 * ModuleInfo.Fastplay;
			}
		}
		int nextEventCycle = NextScanlineCycle;
		macro CHECK_TIMER_IRQ(ch) {
			if (cycle >= Pokeys.Timer##ch##Cycle) {
				Pokeys.Irqst &= ~ch;
				Pokeys.Timer##ch##Cycle = NeverCycle;
			}
			else if (nextEventCycle > Pokeys.Timer##ch##Cycle)
				nextEventCycle = Pokeys.Timer##ch##Cycle;
		}
		CHECK_TIMER_IRQ(1);
		CHECK_TIMER_IRQ(2);
		CHECK_TIMER_IRQ(4);
		NextEventCycle = nextEventCycle;
	}

	int Do6502Frame()
	{
		NextEventCycle = 0;
		NextScanlineCycle = 0;
		Nmist = Nmist == NmiStatus.Reset ? NmiStatus.OnVBlank : NmiStatus.WasVBlank;
		int cycles = ModuleInfo.Ntsc ? 262 * 114 : 312 * 114;
		Cpu.DoFrame(this, cycles);
		Cycle -= cycles;
		if (NextPlayerCycle != NeverCycle)
			NextPlayerCycle -= cycles;
		if (Pokeys.Timer1Cycle != NeverCycle)
			Pokeys.Timer1Cycle -= cycles;
		if (Pokeys.Timer2Cycle != NeverCycle)
			Pokeys.Timer2Cycle -= cycles;
		if (Pokeys.Timer4Cycle != NeverCycle)
			Pokeys.Timer4Cycle -= cycles;
		return cycles;
	}

	int DoFrame()
	{
		Pokeys.StartFrame();
		int cycles = Do6502Frame();
		Pokeys.EndFrame(cycles);
		return cycles;
	}

	/// Loads music data ("module").
	public void Load(
		/// Filename, used to determine the format.
		string filename,
		/// Contents of the file.
		byte[] module,
		/// Length of the file.
		int moduleLen)
	{
		SilenceCycles = 0;
		ModuleInfo.ParseFile(this, filename, module, moduleLen);
	}

	/// Enables silence detection.
	/// Causes playback to stop after the specified period of silence.
	/// Must be called after each call of `Load`.
	public void DetectSilence(
		/// Length of silence which ends playback.
		int seconds)
	{
		SilenceCycles = seconds * Pokeys.MainClock;
	}

	void Do6502Init(int pc, int a, int x, int y)
	{
		Cpu.PC = pc;
		Cpu.A = a & 0xff;
		Cpu.X = x & 0xff;
		Cpu.Y = y & 0xff;
		const int escapeAddr = 0xd200;
		Memory[escapeAddr] = 0xd2; // escape code
		Memory[0x1fe] = (escapeAddr - 1).LowByte; // return address points to the escape code
		Memory[0x1ff] = (escapeAddr - 1) >> 8;
		Cpu.S = 0xfd;
		for (int frame = 0; frame < 50; frame++) {
			Do6502Frame();
			if (Cpu.PC == escapeAddr)
				return;
		}
		throw "INIT routine didn't return";
	}

	/// Mutes the selected POKEY channels.
	public void MutePokeyChannels(
		/// An 8-bit mask which selects POKEY channels to be muted.
		int mask)
	{
		Pokeys.BasePokey.Mute(mask);
		Pokeys.ExtraPokey.Mute(mask >> 4);
	}

	/// Prepares playback of the specified song of the loaded module.
	public void PlaySong(
		/// Zero-based song index.
		int song,
		/// Playback time in milliseconds, -1 means infinity.
		int duration)
	{
		if (song < 0 || song >= ModuleInfo.Songs)
			throw "Song number out of range";
		CurrentSong = song;
		CurrentDuration = duration;
		NextPlayerCycle = NeverCycle;
		BlocksPlayed = 0;
		SilenceCyclesCounter = SilenceCycles;

		Cycle = 0;
		Cpu.NZ = 0;
		Cpu.C = 0;
		Cpu.VDI = 0;
		Nmist = NmiStatus.OnVBlank;
		Consol = 8;
		Covox[0] = 0x80;
		Covox[1] = 0x80;
		Covox[2] = 0x80;
		Covox[3] = 0x80;
		Pokeys.Initialize(ModuleInfo.Channels > 1);
		Pokeys.MainClock = ModuleInfo.Ntsc ? 1789772 : 1773447;
		switch (ModuleInfo.Type) {
		case ASAPModuleType.SAPB:
			Do6502Init(ModuleInfo.Init, song, 0, 0);
			break;
		case ASAPModuleType.SAPC:
#if !ASAP_ONLY_SAP
		case ASAPModuleType.CMC:
		case ASAPModuleType.CM3:
		case ASAPModuleType.CMR:
		case ASAPModuleType.CMS:
#endif
			Do6502Init(ModuleInfo.Player + 3, 0x70, ModuleInfo.Music, ModuleInfo.Music >> 8);
			Do6502Init(ModuleInfo.Player + 3, 0x00, song, 0);
			break;
		case ASAPModuleType.SAPD:
		case ASAPModuleType.SAPS:
			Cpu.PC = ModuleInfo.Init;
			Cpu.A = song;
			Cpu.X = 0x00;
			Cpu.Y = 0x00;
			Cpu.S = 0xff;
			break;
#if !ASAP_ONLY_SAP
		case ASAPModuleType.DLT:
			Do6502Init(ModuleInfo.Player + 0x100, 0x00, 0x00, ModuleInfo.SongPos[song]);
			break;
		case ASAPModuleType.MPT:
			Do6502Init(ModuleInfo.Player, 0x00, ModuleInfo.Music >> 8, ModuleInfo.Music);
			Do6502Init(ModuleInfo.Player, 0x02, ModuleInfo.SongPos[song], 0);
			break;
		case ASAPModuleType.RMT:
			Do6502Init(ModuleInfo.Player, ModuleInfo.SongPos[song], ModuleInfo.Music, ModuleInfo.Music >> 8);
			break;
		case ASAPModuleType.TMC:
		case ASAPModuleType.TM2:
			Do6502Init(ModuleInfo.Player, 0x70, ModuleInfo.Music >> 8, ModuleInfo.Music);
			Do6502Init(ModuleInfo.Player, 0x00, song, 0);
			TmcPerFrameCounter = 1;
			break;
#endif
		}
		MutePokeyChannels(0);
		NextPlayerCycle = 0;
	}

	/// Returns current playback position in milliseconds.
	public int GetPosition()
	{
		return BlocksPlayed * 10 / (SampleRate / 100);
	}

	static int MillisecondsToBlocks(int milliseconds)
	{
		return milliseconds * (SampleRate / 100) / 10;
	}

	/// Changes the playback position.
	public void Seek(
		/// The requested absolute position in milliseconds.
		int position)
	{
		int block = MillisecondsToBlocks(position);
		if (block < BlocksPlayed)
			PlaySong(CurrentSong, CurrentDuration);
		while (BlocksPlayed + Pokeys.Samples < block) {
			BlocksPlayed += Pokeys.Samples;
			DoFrame();
		}
		Pokeys.SampleIndex = block - BlocksPlayed;
		BlocksPlayed = block;
	}

	static void PutLittleEndian(byte[] buffer, int offset, int value)
	{
		buffer[offset] = value.LowByte;
		buffer[offset + 1] = (value >> 8).LowByte;
		buffer[offset + 2] = (value >> 16).LowByte;
		buffer[offset + 3] = (value >> 24).LowByte;
	}

	/// WAV file header length.
	// TODO: <seealso cref="GetWavHeader" />
	public const int WavHeaderBytes = 44;

	/// Fills leading bytes of the specified buffer with WAV file header.
	/// The number of changed bytes is `WavHeaderBytes`.
	// TODO: <see cref="WavHeaderBytes" />
	public void GetWavHeader(
		/// The destination buffer.
		byte[] buffer,
		/// Format of samples.
		ASAPSampleFormat format)
	{
		int use16bit = format != ASAPSampleFormat.U8 ? 1 : 0;
		int blockSize = ModuleInfo.Channels << use16bit;
		int bytesPerSecond = SampleRate * blockSize;
		int totalBlocks = MillisecondsToBlocks(CurrentDuration);
		int nBytes = (totalBlocks - BlocksPlayed) * blockSize;
		buffer[0] = 'R';
		buffer[1] = 'I';
		buffer[2] = 'F';
		buffer[3] = 'F';
		PutLittleEndian(buffer, 4, nBytes + 36);
		buffer[8] = 'W';
		buffer[9] = 'A';
		buffer[10] = 'V';
		buffer[11] = 'E';
		buffer[12] = 'f';
		buffer[13] = 'm';
		buffer[14] = 't';
		buffer[15] = ' ';
		buffer[16] = 16;
		buffer[17] = 0;
		buffer[18] = 0;
		buffer[19] = 0;
		buffer[20] = 1;
		buffer[21] = 0;
		buffer[22] = ModuleInfo.Channels;
		buffer[23] = 0;
		PutLittleEndian(buffer, 24, SampleRate);
		PutLittleEndian(buffer, 28, bytesPerSecond);
		buffer[32] = blockSize;
		buffer[33] = 0;
		buffer[34] = 8 << use16bit;
		buffer[35] = 0;
		buffer[36] = 'd';
		buffer[37] = 'a';
		buffer[38] = 't';
		buffer[39] = 'a';
		PutLittleEndian(buffer, 40, nBytes);
	}

	int GenerateAt(byte[] buffer, int bufferOffset, int bufferLen, ASAPSampleFormat format)
	{
		if (SilenceCycles > 0 && SilenceCyclesCounter <= 0)
			return 0;
		int blockShift =
#if FLASH
			0;
#else
			(ModuleInfo.Channels - 1) + (format != ASAPSampleFormat.U8 ? 1 : 0);
#endif
		int bufferBlocks = bufferLen >> blockShift;
		if (CurrentDuration > 0) {
			int totalBlocks = MillisecondsToBlocks(CurrentDuration);
			if (bufferBlocks > totalBlocks - BlocksPlayed)
				bufferBlocks = totalBlocks - BlocksPlayed;
		}
		int block = 0;
		for (;;) {
			int blocks = Pokeys.Generate(buffer, bufferOffset + (block << blockShift), bufferBlocks - block, format);
			BlocksPlayed += blocks;
			block += blocks;
			if (block >= bufferBlocks)
				break;
			int cycles = DoFrame();
			if (SilenceCycles > 0) {
				if (Pokeys.IsSilent()) {
					SilenceCyclesCounter -= cycles;
					if (SilenceCyclesCounter <= 0)
						break;
				}
				else
					SilenceCyclesCounter = SilenceCycles;
			}
		}
		return block << blockShift;
	}

	/// Fills the specified buffer with generated samples.
	public int Generate(
		/// The destination buffer.
		byte[] buffer,
		/// Number of bytes to fill.
		int bufferLen,
		/// Format of samples.
		ASAPSampleFormat format)
	{
		return GenerateAt(buffer, 0, bufferLen, format);
	}

}
