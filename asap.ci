// asap.ci - ASAP in the Ci programming language
//
// Copyright (C) 2010-2011  Piotr Fusik
//
// This file is part of ASAP (Another Slight Atari Player),
// see http://asap.sourceforge.net
//
// ASAP is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published
// by the Free Software Foundation; either version 2 of the License,
// or (at your option) any later version.
//
// ASAP is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty
// of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with ASAP; if not, write to the Free Software Foundation, Inc.,
// 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

namespace net.Sf.Asap;

public const int VersionMajor = 2;
public const int VersionMinor = 1;
public const int VersionMicro = 3;
public const string Version = VersionMajor + "." + VersionMinor + "." + VersionMicro;

/// Maximum length of a supported input file.
/// You may assume that files longer than this are not supported by ASAP.
public const int ModuleMax = 65000;

/// Maximum number of songs in a file.
public const int SongsMax = 32;

/// Output sample rate.
public const int SampleRate = 44100;

/// WAV file header length.
// TODO: <seealso cref="GetWavHeader" />
public const int WavHeaderBytes = 44;

/// Format of output samples.
public enum ASAP_SampleFormat
{
	/// Unsigned 8-bit.
	U8,
	/// Signed 16-bit little-endian.
	S16LE,
	/// Signed 16-bit big-endian.
	S16BE
}

/// Information about a music file.
public class ASAP_ModuleInfo
{
	/// Author's name.
	/// A nickname may be included in parentheses after the real name.
	/// Multiple authors are separated with `" & "`.
	/// Empty string means the author is unknown.
	public string(127) author;

	/// Music title.
	/// Empty string means the title is unknown.
	public string(127) name;

	/// Music creation date.
	/// Some of the possible formats are:
	/// * YYYY
	/// * MM/YYYY
	/// * DD/MM/YYYY
	/// * YYYY-YYYY
	///
	/// Empty string means the date is unknown.
	public string(127) date;

	/// 1 for mono or 2 for stereo.
	public int channels;

	/// Number of songs in the file.
	public int songs;

	/// 0-based index of the "main" song.
	/// The specified song should be played by default.
	public int default_song;

	/// Lengths of songs.
	/// Each element of the array represents length of one song,
	/// in milliseconds. -1 means the length is indeterminate.
	public int[32] durations;

	/// Information about finite vs infinite songs.
	/// Each element of the array represents one song, and is:
	/// * `true` if the song loops
	/// * `false` if the song stops
	public bool[32] loops;

	bool ntsc;
	int type;
	int fastplay;
	int music;
	int init;
	int player;
	int covox_addr;
	int header_len;
	byte[32] song_pos;
}

class PokeyState
{
	int audctl;
	bool init;
	int poly_index;
	int div_cycles;
	int mute1;
	int mute2;
	int mute3;
	int mute4;
	int audf1;
	int audf2;
	int audf3;
	int audf4;
	int audc1;
	int audc2;
	int audc3;
	int audc4;
	int tick_cycle1;
	int tick_cycle2;
	int tick_cycle3;
	int tick_cycle4;
	int period_cycles1;
	int period_cycles2;
	int period_cycles3;
	int period_cycles4;
	int reload_cycles1;
	int reload_cycles3;
	int out1;
	int out2;
	int out3;
	int out4;
	int delta1;
	int delta2;
	int delta3;
	int delta4;
	int skctl;
	int[888] delta_buffer;
}

class ASAP_State
{
	int cycle;
	int cpu_pc;
	int cpu_a;
	int cpu_x;
	int cpu_y;
	int cpu_s;
	int cpu_nz;
	int cpu_c;
	int cpu_vdi;
	int scanline_number;
	int nearest_event_cycle;
	int next_scanline_cycle;
	int timer1_cycle;
	int timer2_cycle;
	int timer4_cycle;
	int irqst;
	int extra_pokey_mask;
	int consol;
	int nmist;
	byte[4] covox;
	PokeyState() base_pokey;
	PokeyState() extra_pokey;
	int sample_offset;
	int sample_index;
	int samples;
	int iir_acc_left;
	int iir_acc_right;
	public ASAP_ModuleInfo() module_info;
	int tmc_per_frame;
	int tmc_per_frame_counter;
	int current_song;
	int current_duration;
	int blocks_played;
	int silence_cycles;
	int silence_cycles_counter;
	byte[511] poly9_lookup;
	byte[16385] poly17_lookup;
	byte[65536] memory;
}

const int NeverCycle = 0x800000;

const int DeltaShiftPOKEY = 20;
const int DeltaShiftGTIA  = 20;
const int DeltaShiftCOVOX = 17;

// TODO: flags
const int MuteFrequency = 1;
const int MuteInit = 2;
const int MuteUser = 4;
const int MuteSerialInput = 8;

void PokeySound_InitializeChip(PokeyState pst)
{
	pst.audctl = 0;
	pst.init = false;
	pst.poly_index = 15 * 31 * 131071;
	pst.div_cycles = 28;
	pst.mute1 = MuteFrequency | MuteUser;
	pst.mute2 = MuteFrequency | MuteUser;
	pst.mute3 = MuteFrequency | MuteUser;
	pst.mute4 = MuteFrequency | MuteUser;
	pst.audf1 = 0;
	pst.audf2 = 0;
	pst.audf3 = 0;
	pst.audf4 = 0;
	pst.audc1 = 0;
	pst.audc2 = 0;
	pst.audc3 = 0;
	pst.audc4 = 0;
	pst.tick_cycle1 = NeverCycle;
	pst.tick_cycle2 = NeverCycle;
	pst.tick_cycle3 = NeverCycle;
	pst.tick_cycle4 = NeverCycle;
	pst.period_cycles1 = 28;
	pst.period_cycles2 = 28;
	pst.period_cycles3 = 28;
	pst.period_cycles4 = 28;
	pst.reload_cycles1 = 28;
	pst.reload_cycles3 = 28;
	pst.out1 = 0;
	pst.out2 = 0;
	pst.out3 = 0;
	pst.out4 = 0;
	pst.delta1 = 0;
	pst.delta2 = 0;
	pst.delta3 = 0;
	pst.delta4 = 0;
	pst.skctl = 3;
	pst.delta_buffer.Clear();
}

void PokeySound_Initialize(ASAP_State ast)
{
	int reg = 0x1ff;
	for (int i = 0; i < 511; i++) {
		reg = (reg >> 5 ^ reg) & 1 << 8 + reg >> 1;
		ast.poly9_lookup[i] = reg.LowByte;
	}
	reg = 0x1ffff;
	for (int i = 0; i < 16385; i++) {
		reg = (reg >> 5 ^ reg) & 0xff << 9 + reg >> 8;
		ast.poly17_lookup[i] = (reg >> 1).LowByte;
	}
	ast.sample_offset = 0;
	ast.sample_index = 0;
	ast.samples = 0;
	ast.iir_acc_left = 0;
	ast.iir_acc_right = 0;
	PokeySound_InitializeChip(ast.base_pokey);
	PokeySound_InitializeChip(ast.extra_pokey);
}

macro ASAP_MAIN_CLOCK(ast)    ((ast).module_info.ntsc ? 1789772 : 1773447)
macro CYCLE_TO_SAMPLE(cycle)  (((cycle) * SampleRate + ast.sample_offset) / ASAP_MAIN_CLOCK(ast))

/// Fills `delta_buffer` up to `current_cycle` basing on current AUDF/AUDC/AUDCTL values.
void PokeySound_GenerateUntilCycle(ASAP_State ast, PokeyState pst, int current_cycle)
{
	for (;;) {
		int cycle = current_cycle;
		if (cycle > pst.tick_cycle1)
			cycle = pst.tick_cycle1;
		if (cycle > pst.tick_cycle2)
			cycle = pst.tick_cycle2;
		if (cycle > pst.tick_cycle3)
			cycle = pst.tick_cycle3;
		if (cycle > pst.tick_cycle4)
			cycle = pst.tick_cycle4;
		if (cycle == current_cycle)
			break;

		const byte[15] poly4_lookup = { 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1 };
		const byte[31] poly5_lookup = {
			0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1,
			0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1 };
		macro DO_TICK(ch) {
			if (pst.init) {
				switch (pst.audc##ch >> 4) {
				case 10:
				case 14:
					pst.out##ch ^= 1;
					pst.delta_buffer[CYCLE_TO_SAMPLE(cycle)] += pst.delta##ch = -pst.delta##ch;
					break;
				default:
					break;
				}
			}
			else {
				int poly = cycle + pst.poly_index - (ch - 1);
				int newout = pst.out##ch;
				switch (pst.audc##ch >> 4) {
				case 0:
					if (poly5_lookup[poly % 31] != 0) {
						if (pst.audctl & 0x80 != 0)
							newout = ast.poly9_lookup[poly % 511] & 1;
						else {
							poly %= 131071;
							newout = (ast.poly17_lookup[poly >> 3] >> (poly & 7)) & 1;
						}
					}
					break;
				case 2:
				case 6:
					newout ^= poly5_lookup[poly % 31];
					break;
				case 4:
					if (poly5_lookup[poly % 31] != 0)
						newout = poly4_lookup[poly % 15];
					break;
				case 8:
					if (pst.audctl & 0x80 != 0)
						newout = ast.poly9_lookup[poly % 511] & 1;
					else {
						poly %= 131071;
						newout = (ast.poly17_lookup[poly >> 3] >> (poly & 7)) & 1;
					}
					break;
				case 10:
				case 14:
					newout ^= 1;
					break;
				case 12:
					newout = poly4_lookup[poly % 15];
					break;
				default:
					break;
				}
				if (newout != pst.out##ch) {
					pst.out##ch = newout;
					pst.delta_buffer[CYCLE_TO_SAMPLE(cycle)] += pst.delta##ch = -pst.delta##ch;
				}
			}
		}

		if (cycle == pst.tick_cycle3) {
			pst.tick_cycle3 += pst.period_cycles3;
			if (pst.audctl & 4 != 0 && pst.delta1 > 0 && pst.mute1 == 0)
				pst.delta_buffer[CYCLE_TO_SAMPLE(cycle)] += pst.delta1 = -pst.delta1;
			DO_TICK(3);
		}
		if (cycle == pst.tick_cycle4) {
			pst.tick_cycle4 += pst.period_cycles4;
			if (pst.audctl & 8 != 0)
				pst.tick_cycle3 = cycle + pst.reload_cycles3;
			if (pst.audctl & 2 != 0 && pst.delta2 > 0 && pst.mute2 == 0)
				pst.delta_buffer[CYCLE_TO_SAMPLE(cycle)] += pst.delta2 = -pst.delta2;
			DO_TICK(4);
		}
		if (cycle == pst.tick_cycle1) {
			pst.tick_cycle1 += pst.period_cycles1;
			if (pst.skctl & 0x88 == 8) // two-tone, sending 1 (i.e. timer1)
				pst.tick_cycle2 = cycle + pst.period_cycles2;
			DO_TICK(1);
		}
		if (cycle == pst.tick_cycle2) {
			pst.tick_cycle2 += pst.period_cycles2;
			if (pst.audctl & 0x10 != 0)
				pst.tick_cycle1 = cycle + pst.reload_cycles1;
			else if (pst.skctl & 8 != 0) // two-tone
				pst.tick_cycle1 = cycle + pst.period_cycles1;
			DO_TICK(2);
		}
	}
}

#if APOKEYSND
macro CURRENT_CYCLE()  (0)
macro CURRENT_SAMPLE() (0)
macro DO_STORE(reg) {
	if (data == pst.reg)
		break;
	pst.reg = data;
}
#else
macro CURRENT_CYCLE()  (ast.cycle)
macro CURRENT_SAMPLE() (CYCLE_TO_SAMPLE(ast.cycle))
macro DO_STORE(reg) {
	if (data == pst.reg)
		break;
	PokeySound_GenerateUntilCycle(ast, pst, ast.cycle);
	pst.reg = data;
}
#endif // APOKEYSND

macro MUTE_CHANNEL(ch, cond, mask) {
	if (cond) {
		pst.mute##ch |= mask;
		pst.tick_cycle##ch = NeverCycle;
	}
	else {
		pst.mute##ch &= ~mask;
		if (pst.tick_cycle##ch == NeverCycle && pst.mute##ch == 0)
			pst.tick_cycle##ch = CURRENT_CYCLE();
	}
}

void PokeySound_PutByte(ASAP_State ast, int addr, int data)
{
	PokeyState pst = addr & ast.extra_pokey_mask != 0 ? ast.extra_pokey : ast.base_pokey;
	switch (addr & 0xf) {
	case 0x00:
		DO_STORE(audf1);
		const int UltrasoundCycles = 112;
		macro DO_ULTRASOUND(ch) {
			MUTE_CHANNEL(ch, pst.period_cycles##ch <= UltrasoundCycles
				&& (pst.audc##ch >> 4 == 10 || pst.audc##ch >> 4 == 14), MuteFrequency);
		}
		switch (pst.audctl & 0x50) {
		case 0x00:
			pst.period_cycles1 = pst.div_cycles * (data + 1);
			break;
		case 0x10:
			pst.period_cycles2 = pst.div_cycles * (data + 256 * pst.audf2 + 1);
			pst.reload_cycles1 = pst.div_cycles * (data + 1);
			DO_ULTRASOUND(2);
			break;
		case 0x40:
			pst.period_cycles1 = data + 4;
			break;
		case 0x50:
			pst.period_cycles2 = data + 256 * pst.audf2 + 7;
			pst.reload_cycles1 = data + 4;
			DO_ULTRASOUND(2);
			break;
		}
		DO_ULTRASOUND(1);
		break;
	case 0x01:
		macro DO_AUDC(ch) {
			DO_STORE(audc##ch);
			if (data & 0x10 != 0) {
				data = (data & 0xf) << DeltaShiftPOKEY;
				if (pst.mute##ch & MuteUser == 0)
					pst.delta_buffer[CURRENT_SAMPLE()]
						+= pst.delta##ch > 0 ? data - pst.delta##ch : data;
				pst.delta##ch = data;
			}
			else {
				data = (data & 0xf) << DeltaShiftPOKEY;
				DO_ULTRASOUND(ch);
				if (pst.delta##ch > 0) {
					if (pst.mute##ch & MuteUser == 0)
						pst.delta_buffer[CURRENT_SAMPLE()]
							+= data - pst.delta##ch;
					pst.delta##ch = data;
				}
				else
					pst.delta##ch = -data;
			}
			break;
		}
		DO_AUDC(1);
	case 0x02:
		DO_STORE(audf2);
		switch (pst.audctl & 0x50) {
		case 0x00:
		case 0x40:
			pst.period_cycles2 = pst.div_cycles * (data + 1);
			break;
		case 0x10:
			pst.period_cycles2 = pst.div_cycles * (pst.audf1 + 256 * data + 1);
			break;
		case 0x50:
			pst.period_cycles2 = pst.audf1 + 256 * data + 7;
			break;
		}
		DO_ULTRASOUND(2);
		break;
	case 0x03:
		DO_AUDC(2);
	case 0x04:
		DO_STORE(audf3);
		switch (pst.audctl & 0x28) {
		case 0x00:
			pst.period_cycles3 = pst.div_cycles * (data + 1);
			break;
		case 0x08:
			pst.period_cycles4 = pst.div_cycles * (data + 256 * pst.audf4 + 1);
			pst.reload_cycles3 = pst.div_cycles * (data + 1);
			DO_ULTRASOUND(4);
			break;
		case 0x20:
			pst.period_cycles3 = data + 4;
			break;
		case 0x28:
			pst.period_cycles4 = data + 256 * pst.audf4 + 7;
			pst.reload_cycles3 = data + 4;
			DO_ULTRASOUND(4);
			break;
		}
		DO_ULTRASOUND(3);
		break;
	case 0x05:
		DO_AUDC(3);
	case 0x06:
		DO_STORE(audf4);
		switch (pst.audctl & 0x28) {
		case 0x00:
		case 0x20:
			pst.period_cycles4 = pst.div_cycles * (data + 1);
			break;
		case 0x08:
			pst.period_cycles4 = pst.div_cycles * (pst.audf3 + 256 * data + 1);
			break;
		case 0x28:
			pst.period_cycles4 = pst.audf3 + 256 * data + 7;
			break;
		}
		DO_ULTRASOUND(4);
		break;
	case 0x07:
		DO_AUDC(4);
	case 0x08:
		DO_STORE(audctl);
		pst.div_cycles = data & 1 != 0 ? 114 : 28;
		// TODO: tick_cycles
		switch (data & 0x50) {
		case 0x00:
			pst.period_cycles1 = pst.div_cycles * (pst.audf1 + 1);
			pst.period_cycles2 = pst.div_cycles * (pst.audf2 + 1);
			break;
		case 0x10:
			pst.period_cycles1 = pst.div_cycles * 256;
			pst.period_cycles2 = pst.div_cycles * (pst.audf1 + 256 * pst.audf2 + 1);
			pst.reload_cycles1 = pst.div_cycles * (pst.audf1 + 1);
			break;
		case 0x40:
			pst.period_cycles1 = pst.audf1 + 4;
			pst.period_cycles2 = pst.div_cycles * (pst.audf2 + 1);
			break;
		case 0x50:
			pst.period_cycles1 = 256;
			pst.period_cycles2 = pst.audf1 + 256 * pst.audf2 + 7;
			pst.reload_cycles1 = pst.audf1 + 4;
			break;
		}
		DO_ULTRASOUND(1);
		DO_ULTRASOUND(2);
		switch (data & 0x28) {
		case 0x00:
			pst.period_cycles3 = pst.div_cycles * (pst.audf3 + 1);
			pst.period_cycles4 = pst.div_cycles * (pst.audf4 + 1);
			break;
		case 0x08:
			pst.period_cycles3 = pst.div_cycles * 256;
			pst.period_cycles4 = pst.div_cycles * (pst.audf3 + 256 * pst.audf4 + 1);
			pst.reload_cycles3 = pst.div_cycles * (pst.audf3 + 1);
			break;
		case 0x20:
			pst.period_cycles3 = pst.audf3 + 4;
			pst.period_cycles4 = pst.div_cycles * (pst.audf4 + 1);
			break;
		case 0x28:
			pst.period_cycles3 = 256;
			pst.period_cycles4 = pst.audf3 + 256 * pst.audf4 + 7;
			pst.reload_cycles3 = pst.audf3 + 4;
			break;
		}
		DO_ULTRASOUND(3);
		DO_ULTRASOUND(4);
		macro DO_INIT(ch, cond) { MUTE_CHANNEL(ch, pst.init && cond, MuteInit); }
		DO_INIT(1, data & 0x40 == 0);
		DO_INIT(2, data & 0x50 != 0x50);
		DO_INIT(3, data & 0x20 == 0);
		DO_INIT(4, data & 0x28 != 0x28);
		break;
	case 0x09:
		// TODO: reload_cycles, out
		macro DO_STIMER(ch) {
			if (pst.tick_cycle##ch != NeverCycle)
				pst.tick_cycle##ch = ast.cycle + pst.period_cycles##ch;
		}
		DO_STIMER(1);
		DO_STIMER(2);
		DO_STIMER(3);
		DO_STIMER(4);
		break;
	case 0x0f:
		DO_STORE(skctl);
		bool init = data & 3 == 0;
		if (pst.init && !init)
			pst.poly_index = (pst.audctl & 0x80 != 0 ? 15 * 31 * 511 - 1 : 15 * 31 * 131071 - 1) - ast.cycle;
		pst.init = init;
		DO_INIT(1, pst.audctl & 0x40 == 0);
		DO_INIT(2, pst.audctl & 0x50 != 0x50);
		DO_INIT(3, pst.audctl & 0x20 == 0);
		DO_INIT(4, pst.audctl & 0x28 != 0x28);
		MUTE_CHANNEL(3, data & 0x10 != 0, MuteSerialInput);
		MUTE_CHANNEL(4, data & 0x10 != 0, MuteSerialInput);
		break;
	default:
		break;
	}
}

int PokeySound_GetRandom(ASAP_State ast, int addr, int cycle)
{
	PokeyState pst = addr & ast.extra_pokey_mask != 0 ? ast.extra_pokey : ast.base_pokey;
	if (pst.init)
		return 0xff;
	int i = cycle + pst.poly_index;
	if (pst.audctl & 0x80 != 0)
		return ast.poly9_lookup[i % 511];
	else {
		i %= 131071;
		int j = i >> 3;
		i &= 7;
		return (ast.poly17_lookup[j] >> i + ast.poly17_lookup[j + 1] << (8 - i)) & 0xff;
	}
}

void end_frame(ASAP_State ast, PokeyState pst, int cycle_limit)
{
	PokeySound_GenerateUntilCycle(ast, pst, cycle_limit);
	pst.poly_index += cycle_limit;
	int m = pst.audctl & 0x80 != 0 ? 15 * 31 * 511 : 15 * 31 * 131071;
	if (pst.poly_index >= 2 * m)
		pst.poly_index -= m;
	if (pst.tick_cycle1 != NeverCycle)
		pst.tick_cycle1 -= cycle_limit;
	if (pst.tick_cycle2 != NeverCycle)
		pst.tick_cycle2 -= cycle_limit;
	if (pst.tick_cycle3 != NeverCycle)
		pst.tick_cycle3 -= cycle_limit;
	if (pst.tick_cycle4 != NeverCycle)
		pst.tick_cycle4 -= cycle_limit;
}

void PokeySound_StartFrame(ASAP_State ast)
{
	ast.base_pokey.delta_buffer.Clear();
	if (ast.extra_pokey_mask != 0)
		ast.extra_pokey.delta_buffer.Clear();
}

void PokeySound_EndFrame(ASAP_State ast, int current_cycle)
{
	end_frame(ast, ast.base_pokey, current_cycle);
	if (ast.extra_pokey_mask != 0)
		end_frame(ast, ast.extra_pokey, current_cycle);
	ast.sample_offset += current_cycle * SampleRate;
	ast.sample_index = 0;
	int clk = ASAP_MAIN_CLOCK(ast);
	ast.samples = ast.sample_offset / clk;
	ast.sample_offset %= clk;
}

/// Fills buffer with samples from `delta_buffer`.
int PokeySound_Generate(ASAP_State ast, byte[] buffer, int buffer_offset, int blocks, ASAP_SampleFormat format)
{
	int i = ast.sample_index;
	int samples = ast.samples;
	int acc_left = ast.iir_acc_left;
	int acc_right = ast.iir_acc_right;
	if (blocks < samples - i)
		samples = i + blocks;
	else
		blocks = samples - i;
	for (; i < samples; i++) {
		acc_left += ast.base_pokey.delta_buffer[i] - (acc_left * 3 >> 10);
#if FLASH
//		var sample : Number = acc_left / 33553408;
//		buffer.writeFloat(sample);
//		if (ast.extra_pokey_mask != 0) {
//			acc_right += ast.extra_pokey.delta_buffer[i] - (acc_right * 3 >> 10);
//			sample = acc_right / 33553408;
//		}
//		buffer.writeFloat(sample);
#else
		int sample = acc_left >> 10;
		macro STORE_SAMPLE() {
			if (sample < -32767)
				sample = -32767;
			else if (sample > 32767)
				sample = 32767;
			switch (format) {
			case ASAP_SampleFormat.U8:
				buffer[buffer_offset++] = sample >> 8 + 128;
				break;
			case ASAP_SampleFormat.S16LE:
				buffer[buffer_offset++] = sample.LowByte;
				buffer[buffer_offset++] = (sample >> 8).LowByte;
				break;
			case ASAP_SampleFormat.S16BE:
				buffer[buffer_offset++] = (sample >> 8).LowByte;
				buffer[buffer_offset++] = sample.LowByte;
				break;
			}
		}
		STORE_SAMPLE();
		if (ast.extra_pokey_mask != 0) {
			acc_right += ast.extra_pokey.delta_buffer[i] - (acc_right * 3 >> 10);
			sample = acc_right >> 10;
			STORE_SAMPLE();
		}
#endif // FLASH
	}
	if (i == ast.samples) {
		acc_left += ast.base_pokey.delta_buffer[i];
		acc_right += ast.extra_pokey.delta_buffer[i];
	}
	ast.sample_index = i;
	ast.iir_acc_left = acc_left;
	ast.iir_acc_right = acc_right;
#if APOKEYSND
	return buffer_offset;
#else
	return blocks;
#endif
}

bool PokeySound_IsSilent(PokeyState pst)
{
	return (pst.audc1 | pst.audc2 | pst.audc3 | pst.audc4) & 0xf == 0;
}

void PokeySound_Mute(ASAP_State ast, PokeyState pst, int mask)
{
	MUTE_CHANNEL(1, mask & 1 != 0, MuteUser);
	MUTE_CHANNEL(2, mask & 2 != 0, MuteUser);
	MUTE_CHANNEL(3, mask & 4 != 0, MuteUser);
	MUTE_CHANNEL(4, mask & 8 != 0, MuteUser);
}

// TODO: enum
const int NmistReset = 0;
const int NmistOnVBlank = 1;
const int NmistWasVBlank = 2;

macro dGetByte(addr)          (ast.memory[addr])
macro dPutByte(addr, data)    { ast.memory[addr] = (data); }
macro dGetWord(addr)          (dGetByte(addr) + dGetByte((addr) + 1) << 8)

int ASAP_GetByte(ASAP_State ast, int addr)
{
	switch (addr & 0xff1f) {
	case 0xd014:
		return ast.module_info.ntsc ? 0xf : 1;
	case 0xd20a:
	case 0xd21a:
		return PokeySound_GetRandom(ast, addr, ast.cycle);
	case 0xd20e:
		return ast.irqst;
	case 0xd21e:
		if (ast.extra_pokey_mask != 0) {
			// interrupts in the extra POKEY not emulated at the moment
			return 0xff;
		}
		return ast.irqst;
	case 0xd20c:
	case 0xd21c:
	case 0xd20f: // just because some SAP files rely on this
	case 0xd21f:
		return 0xff;
	case 0xd40b:
	case 0xd41b:
		if (ast.scanline_number == 0 && ast.cycle == 13)
			return ast.module_info.ntsc ? 131 : 156;
		return ast.scanline_number >> 1;
	case 0xd40f:
		if (ast.nmist == NmistWasVBlank)
			return 0x5f;
		if (ast.nmist == NmistReset)
			return 0x1f;
		// NmistOnVBlank
		return ast.cycle < 28295 ? 0x1f : 0x5f;
	default:
		return dGetByte(addr);
	}
}

void ASAP_PutByte(ASAP_State ast, int addr, int data)
{
	if (addr >> 8 == 0xd2) {
		if (addr & (ast.extra_pokey_mask + 0xf) == 0xe) {
			ast.irqst |= data ^ 0xff;
			macro SET_TIMER_IRQ(ch) {
				if (data & ast.irqst & ch != 0) {
					if (ast.timer##ch##_cycle == NeverCycle) {
						int t = ast.base_pokey.tick_cycle##ch;
						while (t < ast.cycle)
							t += ast.base_pokey.period_cycles##ch;
						ast.timer##ch##_cycle = t;
						if (ast.nearest_event_cycle > t)
							ast.nearest_event_cycle = t;
					}
				}
				else
					ast.timer##ch##_cycle = NeverCycle;
			}
			SET_TIMER_IRQ(1);
			SET_TIMER_IRQ(2);
			SET_TIMER_IRQ(4);
		}
		else
			PokeySound_PutByte(ast, addr, data);
	}
	else if (addr & 0xff0f == 0xd40a) {
		if (ast.cycle <= ast.next_scanline_cycle - 4)
			ast.cycle = ast.next_scanline_cycle - 4;
		else
			ast.cycle = ast.next_scanline_cycle + 110;
	}
	else if (addr & 0xff0f == 0xd40f) {
		ast.nmist = ast.cycle < 28296 ? NmistOnVBlank : NmistReset;
	}
	else if (addr & 0xff00 == ast.module_info.covox_addr) {
		PokeyState pst;
		addr &= 3;
		if (addr == 0 || addr == 3)
			pst = ast.base_pokey;
		else
			pst = ast.extra_pokey;
		pst.delta_buffer[CYCLE_TO_SAMPLE(ast.cycle)] += (data - ast.covox[addr]) << DeltaShiftCOVOX;
		ast.covox[addr] = data;
	}
	else if (addr & 0xff1f == 0xd01f) {
		data &= 8;
		// NOT data - ast.consol; reverse to the POKEY sound
		int delta = (ast.consol - data) << DeltaShiftGTIA;
		ast.consol = data;
		int sample = CYCLE_TO_SAMPLE(ast.cycle);
		ast.base_pokey.delta_buffer[sample] += delta;
		ast.extra_pokey.delta_buffer[sample] += delta;
	}
	else
		dPutByte(addr, data);
}

macro GetByte(addr)           ((addr) & 0xf900 == 0xd000 ? ASAP_GetByte(ast, addr) : dGetByte(addr))
macro PutByte(addr, data)     { if ((addr) & 0xf900 == 0xd000) ASAP_PutByte(ast, addr, data); else dPutByte(addr, data); }

const int CpuVFlag = 0x40;
const int CpuDFlag = 0x08;
const int CpuIFlag = 0x04;
const int CpuZFlag = 0x02;

// How 6502 registers are stored in this emulator:
// All variables are int, because modern processors (and Java bytecode)
// tend to operate more effectively on these type than narrower ones.
// pc is really an unsigned 16-bit integer.
// a, x, y and s are unsigned 8-bit integers.
// Flags are decomposed into three variables for improved performance.
// c is either 0 or 1.
// nz contains 6502 flags N and Z.
// N is set if (nz >= 0x80). Z is set if ((nz & 0xff) == 0).
// Usually nz is simply assigned the unsigned 8-bit operation result.
// There are just a few operations (ADC in decimal mode, BIT, PLP and RTI)
// where both N and Z may be set. In these cases, N is reflected by the 8th
// (not 7th) bit of nz.
// vdi contains rarely used flags V, D and I, as a combination
// of CpuVFlag, CpuDFlag and CpuIFlag. Other vdi bits are clear.

// "Unofficial" opcodes are those not documented as "legal" 6502 opcodes.
// Their operation has been reverse-engineered on Atari 800XL and Atari 65XE.
// Unofficial opcodes are identical to C64's 6510, except for 0x8b and 0xab.
// The operation of "unstable" opcodes is partially uncertain.
// Explanation is welcome.

// Emulation of POKEY timer interrupts is included.

// Two preprocessor symbols may be used to strip the size of this emulator.
// Define ACPU_NO_DECIMAL to disable emulation of the BCD mode.
// Define ACPU_NO_UNOFFICIAL to disable emulation of unofficial opcodes.

/// Runs 6502 emulation for the specified number of Atari scanlines.
/// Each scanline is 114 cycles of which 9 is taken by ANTIC for memory refresh.
void Cpu_RunScanlines(ASAP_State ast, int scanlines)
{
	// copy registers from ASAP_State to local variables for improved performance
	int pc = ast.cpu_pc;
	int nz = ast.cpu_nz;
	int a = ast.cpu_a;
	int x = ast.cpu_x;
	int y = ast.cpu_y;
	int c = ast.cpu_c;
	int s = ast.cpu_s;
	int vdi = ast.cpu_vdi;
	ast.next_scanline_cycle = 114;
	int next_event_cycle = 114;
	int cycle_limit = 114 * scanlines;
	if (next_event_cycle > ast.timer1_cycle)
		next_event_cycle = ast.timer1_cycle;
	if (next_event_cycle > ast.timer2_cycle)
		next_event_cycle = ast.timer2_cycle;
	if (next_event_cycle > ast.timer4_cycle)
		next_event_cycle = ast.timer4_cycle;
	ast.nearest_event_cycle = next_event_cycle;
	for (;;) {

		macro RMW_GetByte(dest, addr) {
			if ((addr) >> 8 == 0xd2) {
				dest = ASAP_GetByte(ast, addr);
				ast.cycle--;
				ASAP_PutByte(ast, addr, dest);
				ast.cycle++;
			}
			else
				dest = dGetByte(addr);
		}

		macro zGetByte(addr)  (dGetByte((addr) & 0xff))

		macro PEEK()       (dGetByte(pc))
		macro FETCH()      (dGetByte(pc++))

		macro ABSOLUTE()   { addr = FETCH(); addr += FETCH() << 8; }
		macro ABSOLUTE_X() { addr = FETCH(); addr = (addr + FETCH() << 8 + x) & 0xffff; }
		macro ABSOLUTE_Y() { addr = FETCH(); addr = (addr + FETCH() << 8 + y) & 0xffff; }
		macro ZPAGE()      { addr = FETCH(); }
		macro ZPAGE_X()    { addr = (FETCH() + x) & 0xff; }
		macro ZPAGE_Y()    { addr = (FETCH() + y) & 0xff; }
		macro INDIRECT_X() { addr = (FETCH() + x) & 0xff; addr = dGetByte(addr) + (zGetByte(addr + 1) << 8); }
		macro INDIRECT_Y() { addr = FETCH(); addr = (dGetByte(addr) + (zGetByte(addr + 1) << 8) + y) & 0xffff; }
		macro NCYCLES_X()  { if (addr & 0xff < x) ast.cycle++; }
		macro NCYCLES_Y()  { if (addr & 0xff < y) ast.cycle++; }

		macro PL(dest)     { s = (s + 1) & 0xff; dest = dGetByte(0x0100 + s); }
		macro PLP()        { PL(vdi); nz = ((vdi & 0x80) << 1) + (~vdi & CpuZFlag); c = vdi & 1; vdi &= CpuVFlag | CpuDFlag | CpuIFlag; }
		macro PH(data)     { dPutByte(0x0100 + s, data); s = (s - 1) & 0xff; }
		macro PHP(bflag)   { PH(((nz | (nz >> 1)) & 0x80) + vdi + (nz & 0xff == 0 ? CpuZFlag : 0) + c + bflag); }
		macro PHPB0()      { PHP(0x20); }  // push flags with B flag clear (NMI, IRQ)
		macro PHPB1()      { PHP(0x30); }  // push flags with B flag set (PHP, BRK)
		macro PHPC()       { PH(pc >> 8); PH(pc.LowByte); }

#if ACPU_NO_DECIMAL

		macro DO_ADC() {{
			// binary mode
			int tmp = a + data + c;
			vdi = (vdi & (CpuDFlag | CpuIFlag)) + (((~(data ^ a) & (a ^ tmp)) >> 1) & CpuVFlag);
			c = tmp >> 8;
			nz = a = tmp & 0xff;
		}}

		macro DO_SBC() {{
			// binary mode
			int tmp = a - data - 1 + c;
			vdi = (vdi & (CpuDFlag | CpuIFlag)) + ((((data ^ a) & (a ^ tmp)) >> 1) & CpuVFlag);
			c = tmp >= 0 ? 1 : 0;
			nz = a = tmp & 0xff;
		}}

#else // ACPU_NO_DECIMAL

		macro DO_ADC() {{
			int tmp = a + data + c;
			nz = tmp & 0xff;
			if (vdi & CpuDFlag == 0) {
				// binary mode
				vdi = (vdi & (CpuDFlag | CpuIFlag)) + (((~(data ^ a) & (a ^ tmp)) >> 1) & CpuVFlag);
				c = tmp >> 8;
				a = nz;
			}
			else {
				// decimal mode
				int al = (a & 0x0f) + (data & 0x0f) + c;
				if (al >= 10)
					tmp += al < 26 ? 6 : -10;
				nz = ((tmp & 0x80) << 1) + (nz != 0 ? 1 : 0);
				vdi = (vdi & (CpuDFlag | CpuIFlag)) + (((~(data ^ a) & (a ^ tmp)) >> 1) & CpuVFlag);
				if (tmp >= 0xa0) {
					c = 1;
					a = (tmp + 0x60) & 0xff;
				}
				else {
					c = 0;
					a = tmp;
				}
			}
		}}

		macro DO_SBC() {{
			int tmp = a - data - 1 + c;
			int al = (a & 0x0f) - (data & 0x0f) - 1 + c;
			vdi = (vdi & (CpuDFlag | CpuIFlag)) + ((((data ^ a) & (a ^ tmp)) >> 1) & CpuVFlag);
			c = tmp >= 0 ? 1 : 0;
			nz = a = tmp & 0xff;
			if (vdi & CpuDFlag != 0) {
				// decimal mode
				if (al < 0)
					a += (al < -10) ? 10 : -6;
				if (c == 0)
					a = (a - 0x60) & 0xff;
			}
		}}

#endif // ACPU_NO_DECIMAL

		macro LDA()        { nz = a = GetByte(addr); }
		macro LDA_ZP()     { nz = a = dGetByte(addr); }
		macro LDX()        { nz = x = GetByte(addr); }
		macro LDX_ZP()     { nz = x = dGetByte(addr); }
		macro LDY()        { nz = y = GetByte(addr); }
		macro LDY_ZP()     { nz = y = dGetByte(addr); }
		macro LAX()        { nz = x = a = GetByte(addr); }
		macro LAX_ZP()     { nz = x = a = dGetByte(addr); }
		macro STA()        { PutByte(addr, a); }
		macro STA_ZP()     { dPutByte(addr, a); }
		macro STX()        { PutByte(addr, x); }
		macro STX_ZP()     { dPutByte(addr, x); }
		macro STY()        { PutByte(addr, y); }
		macro STY_ZP()     { dPutByte(addr, y); }
		macro SAX()        { data = a & x; PutByte(addr, data); }
		macro SAX_ZP()     { data = a & x; dPutByte(addr, data); }
		macro CMP()        { nz = GetByte(addr); c = a >= nz ? 1 : 0; nz = (a - nz) & 0xff; }
		macro CMP_ZP()     { nz = dGetByte(addr); c = a >= nz ? 1 : 0; nz = (a - nz) & 0xff; }
		macro CPX()        { nz = GetByte(addr); c = x >= nz ? 1 : 0; nz = (x - nz) & 0xff; }
		macro CPX_ZP()     { nz = dGetByte(addr); c = x >= nz ? 1 : 0; nz = (x - nz) & 0xff; }
		macro CPY()        { nz = GetByte(addr); c = y >= nz ? 1 : 0; nz = (y - nz) & 0xff; }
		macro CPY_ZP()     { nz = dGetByte(addr); c = y >= nz ? 1 : 0; nz = (y - nz) & 0xff; }
		macro AND()        { nz = a &= GetByte(addr); }
		macro AND_ZP()     { nz = a &= dGetByte(addr); }
		macro ORA()        { nz = a |= GetByte(addr); }
		macro ORA_ZP()     { nz = a |= dGetByte(addr); }
		macro EOR()        { nz = a ^= GetByte(addr); }
		macro EOR_ZP()     { nz = a ^= dGetByte(addr); }
		macro ADC()        { data = GetByte(addr); DO_ADC(); }
		macro ADC_ZP()     { data = dGetByte(addr); DO_ADC(); }
		macro SBC()        { data = GetByte(addr); DO_SBC(); }
		macro SBC_ZP()     { data = dGetByte(addr); DO_SBC(); }

		macro ASL()        { RMW_GetByte(nz, addr); c = nz >> 7; nz = (nz << 1) & 0xff; PutByte(addr, nz); }
		macro ASL_ZP()     { nz = dGetByte(addr); c = nz >> 7; nz = (nz << 1) & 0xff; dPutByte(addr, nz); }
		macro ROL()        { RMW_GetByte(nz, addr); nz = nz << 1 + c; c = nz >> 8; nz &= 0xff; PutByte(addr, nz); }
		macro ROL_ZP()     { nz = dGetByte(addr); nz = nz << 1 + c; c = nz >> 8; nz &= 0xff; dPutByte(addr, nz); }
		macro LSR()        { RMW_GetByte(nz, addr); c = nz & 1; nz >>= 1; PutByte(addr, nz); }
		macro LSR_ZP()     { nz = dGetByte(addr); c = nz & 1; nz >>= 1; dPutByte(addr, nz); }
		macro ROR()        { RMW_GetByte(nz, addr); nz += c << 8; c = nz & 1; nz >>= 1; PutByte(addr, nz); }
		macro ROR_ZP()     { nz = dGetByte(addr) + c << 8; c = nz & 1; nz >>= 1; dPutByte(addr, nz); }
		macro DEC()        { RMW_GetByte(nz, addr); nz = (nz - 1) & 0xff; PutByte(addr, nz); }
		macro DEC_ZP()     { nz = dGetByte(addr); nz = (nz - 1) & 0xff; dPutByte(addr, nz); }
		macro INC()        { RMW_GetByte(nz, addr); nz = (nz + 1) & 0xff; PutByte(addr, nz); }
		macro INC_ZP()     { nz = dGetByte(addr); nz = (nz + 1) & 0xff; dPutByte(addr, nz); }

		macro ASO()        { ASL(); nz = a |= nz; }
		macro ASO_ZP()     { ASL_ZP(); nz = a |= nz; }
		macro RLA()        { ROL(); nz = a &= nz; }
		macro RLA_ZP()     { ROL_ZP(); nz = a &= nz; }
		macro LSE()        { LSR(); nz = a ^= nz; }
		macro LSE_ZP()     { LSR_ZP(); nz = a ^= nz; }
		macro RRA()        { ROR(); data = nz; DO_ADC(); }
		macro RRA_ZP()     { ROR_ZP(); data = nz; DO_ADC(); }
		macro DCM()        { DEC(); c = a >= nz ? 1 : 0; nz = (a - nz) & 0xff; }
		macro DCM_ZP()     { DEC_ZP(); c = a >= nz ? 1 : 0; nz = (a - nz) & 0xff; }
		macro INS()        { INC(); data = nz; DO_SBC(); }
		macro INS_ZP()     { INC_ZP(); data = nz; DO_SBC(); }

		macro SHX(val,ind) {{
			addr = FETCH();
			int hi = FETCH();
			data = (hi + 1) & val;
			addr += ind;
			if (addr >= 0x100)
				hi = data - 1;
			addr += hi << 8;
			PutByte(addr, data);
		}}

		macro BRANCH(cond) {
			if (cond) {
				addr = PEEK().SByte; // TODO
				pc++;
				addr += pc;
				if ((addr ^ pc) >> 8 != 0)
					ast.cycle++;
				ast.cycle++;
				pc = addr;
				break;
			}
			pc++;
			break;
		}

		macro CHECK_IRQ()  {
			if (vdi & CpuIFlag == 0 && ast.irqst != 0xff) {
				PHPC();
				PHPB0();
				vdi |= CpuIFlag;
				pc = dGetWord(0xfffe);
				ast.cycle += 7;
			}
		}

		int cycle = ast.cycle;
		if (cycle >= ast.nearest_event_cycle) {
			if (cycle >= ast.next_scanline_cycle) {
				if (++ast.scanline_number == (ast.module_info.ntsc ? 262 : 312)) {
					ast.scanline_number = 0;
					ast.nmist = ast.nmist == NmistReset ? NmistOnVBlank : NmistWasVBlank;
				}
				if (ast.cycle - ast.next_scanline_cycle < 50) // not WSYNC
					ast.cycle = cycle += 9;
				ast.next_scanline_cycle += 114;
				if (--scanlines <= 0)
					break;
			}
			next_event_cycle = ast.next_scanline_cycle;
			macro CHECK_TIMER_IRQ(ch) {
				if (cycle >= ast.timer##ch##_cycle) {
					ast.irqst &= ~ch;
					ast.timer##ch##_cycle = NeverCycle;
				}
				else if (next_event_cycle > ast.timer##ch##_cycle)
					next_event_cycle = ast.timer##ch##_cycle;
			}
			CHECK_TIMER_IRQ(1);
			CHECK_TIMER_IRQ(2);
			CHECK_TIMER_IRQ(4);
			ast.nearest_event_cycle = next_event_cycle;
			CHECK_IRQ();
		}

#if ASAPSCAN
		if (cpu_trace != 0)
			trace_cpu(ast, pc, a, x, y, s, nz, vdi, c);
#endif
		int data = FETCH();
		const int[256] opcode_cycles = {
		//	0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F 
			7, 6, 2, 8, 3, 3, 5, 5, 3, 2, 2, 2, 4, 4, 6, 6, // 0x
			2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7, // 1x 
			6, 6, 2, 8, 3, 3, 5, 5, 4, 2, 2, 2, 4, 4, 6, 6, // 2x
			2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7, // 3x
			6, 6, 2, 8, 3, 3, 5, 5, 3, 2, 2, 2, 3, 4, 6, 6, // 4x
			2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7, // 5x
			6, 6, 2, 8, 3, 3, 5, 5, 4, 2, 2, 2, 5, 4, 6, 6, // 6x
			2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7, // 7x
			2, 6, 2, 6, 3, 3, 3, 3, 2, 2, 2, 2, 4, 4, 4, 4, // 8x
			2, 6, 2, 6, 4, 4, 4, 4, 2, 5, 2, 5, 5, 5, 5, 5, // 9x
			2, 6, 2, 6, 3, 3, 3, 3, 2, 2, 2, 2, 4, 4, 4, 4, // Ax
			2, 5, 2, 5, 4, 4, 4, 4, 2, 4, 2, 4, 4, 4, 4, 4, // Bx
			2, 6, 2, 8, 3, 3, 5, 5, 2, 2, 2, 2, 4, 4, 6, 6, // Cx
			2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7, // Dx
			2, 6, 2, 8, 3, 3, 5, 5, 2, 2, 2, 2, 4, 4, 6, 6, // Ex
			2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7  // Fx
		};
		ast.cycle += opcode_cycles[data];
		int addr;

		switch (data) {
		case 0x00: // BRK
			pc++;
			PHPC();
			PHPB1();
			vdi |= CpuIFlag;
			pc = dGetWord(0xfffe);
			break;
		case 0x01: // ORA (ab,x)
			INDIRECT_X();
			ORA();
			break;
		case 0x02: // CIM [unofficial]
		case 0x12:
		case 0x22:
		case 0x32:
		case 0x42:
		case 0x52:
		case 0x62:
		case 0x72:
		case 0x92:
		case 0xb2:
		case 0xd2:
		case 0xf2:
			ast.scanline_number = (ast.scanline_number + scanlines - 1) % (ast.module_info.ntsc ? 262 : 312);
			scanlines = 1;
			ast.cycle = cycle_limit;
			break;
		case 0x05: // ORA ab
			ZPAGE();
			ORA_ZP();
			break;
		case 0x06: // ASL ab
			ZPAGE();
			ASL_ZP();
			break;
		case 0x08: // PHP
			PHPB1();
			break;
		case 0x09: // ORA #ab
			nz = a |= FETCH();
			break;
		case 0x0a: // ASL
			c = a >> 7;
			nz = a = (a << 1) & 0xff;
			break;
		case 0x0d: // ORA abcd
			ABSOLUTE();
			ORA();
			break;
		case 0x0e: // ASL abcd
			ABSOLUTE();
			ASL();
			break;
		case 0x10: // BPL
			BRANCH(nz < 0x80);
		case 0x11: // ORA (ab),y
			INDIRECT_Y();
			NCYCLES_Y();
			ORA();
			break;
		case 0x15: // ORA ab,x
			ZPAGE_X();
			ORA_ZP();
			break;
		case 0x16: // ASL ab,x
			ZPAGE_X();
			ASL_ZP();
			break;
		case 0x18: // CLC
			c = 0;
			break;
		case 0x19: // ORA abcd,y
			ABSOLUTE_Y();
			NCYCLES_Y();
			ORA();
			break;
		case 0x1d: // ORA abcd,x
			ABSOLUTE_X();
			NCYCLES_X();
			ORA();
			break;
		case 0x1e: // ASL abcd,x
			ABSOLUTE_X();
			ASL();
			break;
		case 0x20: // JSR abcd
			addr = FETCH();
			PHPC();
			pc = addr + PEEK() << 8;
			break;
		case 0x21: // AND (ab,x)
			INDIRECT_X();
			AND();
			break;
		case 0x24: // BIT ab
			ZPAGE();
			nz = dGetByte(addr);
			vdi = (vdi & (CpuDFlag | CpuIFlag)) + (nz & CpuVFlag);
			nz = ((nz & 0x80) << 1) + (nz & a);
			break;
		case 0x25: // AND ab
			ZPAGE();
			AND_ZP();
			break;
		case 0x26: // ROL ab
			ZPAGE();
			ROL_ZP();
			break;
		case 0x28: // PLP
			PLP();
			CHECK_IRQ();
			break;
		case 0x29: // AND #ab
			nz = a &= FETCH();
			break;
		case 0x2a: // ROL
			a = (a << 1) + c;
			c = a >> 8;
			nz = a &= 0xff;
			break;
		case 0x2c: // BIT abcd
			ABSOLUTE();
			nz = GetByte(addr);
			vdi = (vdi & (CpuDFlag | CpuIFlag)) + (nz & CpuVFlag);
			nz = ((nz & 0x80) << 1) + (nz & a);
			break;
		case 0x2d: // AND abcd
			ABSOLUTE();
			AND();
			break;
		case 0x2e: // ROL abcd
			ABSOLUTE();
			ROL();
			break;
		case 0x30: // BMI
			BRANCH(nz >= 0x80);
		case 0x31: // AND (ab),y
			INDIRECT_Y();
			NCYCLES_Y();
			AND();
			break;
		case 0x35: // AND ab,x
			ZPAGE_X();
			AND_ZP();
			break;
		case 0x36: // ROL ab,x
			ZPAGE_X();
			ROL_ZP();
			break;
		case 0x38: // SEC
			c = 1;
			break;
		case 0x39: // AND abcd,y
			ABSOLUTE_Y();
			NCYCLES_Y();
			AND();
			break;
		case 0x3d: // AND abcd,x
			ABSOLUTE_X();
			NCYCLES_X();
			AND();
			break;
		case 0x3e: // ROL abcd,x
			ABSOLUTE_X();
			ROL();
			break;
		case 0x40: // RTI
			PLP();
			PL(pc);
			PL(addr);
			pc += addr << 8;
			CHECK_IRQ();
			break;
		case 0x41: // EOR (ab,x)
			INDIRECT_X();
			EOR();
			break;
		case 0x45: // EOR ab
			ZPAGE();
			EOR_ZP();
			break;
		case 0x46: // LSR ab
			ZPAGE();
			LSR_ZP();
			break;
		case 0x48: // PHA
			PH(a);
			break;
		case 0x49: // EOR #ab
			nz = a ^= FETCH();
			break;
		case 0x4a: // LSR
			c = a & 1;
			nz = a >>= 1;
			break;
		case 0x4c: // JMP abcd
			addr = FETCH();
			pc = addr + PEEK() << 8;
			break;
		case 0x4d: // EOR abcd
			ABSOLUTE();
			EOR();
			break;
		case 0x4e: // LSR abcd
			ABSOLUTE();
			LSR();
			break;
		case 0x50: // BVC
			BRANCH(vdi & CpuVFlag == 0);
		case 0x51: // EOR (ab),y
			INDIRECT_Y();
			NCYCLES_Y();
			EOR();
			break;
		case 0x55: // EOR ab,x
			ZPAGE_X();
			EOR_ZP();
			break;
		case 0x56: // LSR ab,x
			ZPAGE_X();
			LSR_ZP();
			break;
		case 0x58: // CLI
			vdi &= CpuVFlag | CpuDFlag;
			CHECK_IRQ();
			break;
		case 0x59: // EOR abcd,y
			ABSOLUTE_Y();
			NCYCLES_Y();
			EOR();
			break;
		case 0x5d: // EOR abcd,x
			ABSOLUTE_X();
			NCYCLES_X();
			EOR();
			break;
		case 0x5e: // LSR abcd,x
			ABSOLUTE_X();
			LSR();
			break;
		case 0x60: // RTS
			PL(pc);
			PL(addr);
			pc += (addr << 8) + 1;
			break;
		case 0x61: // ADC (ab,x)
			INDIRECT_X();
			ADC();
			break;
		case 0x65: // ADC ab
			ZPAGE();
			ADC_ZP();
			break;
		case 0x66: // ROR ab
			ZPAGE();
			ROR_ZP();
			break;
		case 0x68: // PLA
			PL(a);
			nz = a;
			break;
		case 0x69: // ADC #ab
			data = FETCH();
			DO_ADC();
			break;
		case 0x6a: // ROR
			nz = (c << 7) + (a >> 1);
			c = a & 1;
			a = nz;
			break;
		case 0x6c: // JMP (abcd)
			ABSOLUTE();
			if (addr & 0xff == 0xff)
				pc = dGetByte(addr - 0xff) << 8 + dGetByte(addr);
			else
				pc = dGetWord(addr);
			break;
		case 0x6d: // ADC abcd
			ABSOLUTE();
			ADC();
			break;
		case 0x6e: // ROR abcd
			ABSOLUTE();
			ROR();
			break;
		case 0x70: // BVS
			BRANCH(vdi & CpuVFlag != 0);
		case 0x71: // ADC (ab),y
			INDIRECT_Y();
			NCYCLES_Y();
			ADC();
			break;
		case 0x75: // ADC ab,x
			ZPAGE_X();
			ADC_ZP();
			break;
		case 0x76: // ROR ab,x
			ZPAGE_X();
			ROR_ZP();
			break;
		case 0x78: // SEI
			vdi |= CpuIFlag;
			break;
		case 0x79: // ADC abcd,y
			ABSOLUTE_Y();
			NCYCLES_Y();
			ADC();
			break;
		case 0x7d: // ADC abcd,x
			ABSOLUTE_X();
			NCYCLES_X();
			ADC();
			break;
		case 0x7e: // ROR abcd,x
			ABSOLUTE_X();
			ROR();
			break;
		case 0x81: // STA (ab,x)
			INDIRECT_X();
			STA();
			break;
		case 0x84: // STY ab
			ZPAGE();
			STY_ZP();
			break;
		case 0x85: // STA ab
			ZPAGE();
			STA_ZP();
			break;
		case 0x86: // STX ab
			ZPAGE();
			STX_ZP();
			break;
		case 0x88: // DEY
			nz = y = (y - 1) & 0xff;
			break;
		case 0x8a: // TXA
			nz = a = x;
			break;
		case 0x8c: // STY abcd
			ABSOLUTE();
			STY();
			break;
		case 0x8d: // STA abcd
			ABSOLUTE();
			STA();
			break;
		case 0x8e: // STX abcd
			ABSOLUTE();
			STX();
			break;
		case 0x90: // BCC
			BRANCH(c == 0);
		case 0x91: // STA (ab),y
			INDIRECT_Y();
			STA();
			break;
		case 0x94: // STY ab,x
			ZPAGE_X();
			STY_ZP();
			break;
		case 0x95: // STA ab,x
			ZPAGE_X();
			STA_ZP();
			break;
		case 0x96: // STX ab,y
			ZPAGE_Y();
			STX_ZP();
			break;
		case 0x98: // TYA
			nz = a = y;
			break;
		case 0x99: // STA abcd,y
			ABSOLUTE_Y();
			STA();
			break;
		case 0x9a: // TXS
			s = x;
			break;
		case 0x9d: // STA abcd,x
			ABSOLUTE_X();
			STA();
			break;
		case 0xa0: // LDY #ab
			nz = y = FETCH();
			break;
		case 0xa1: // LDA (ab,x)
			INDIRECT_X();
			LDA();
			break;
		case 0xa2: // LDX #ab
			nz = x = FETCH();
			break;
		case 0xa4: // LDY ab
			ZPAGE();
			LDY_ZP();
			break;
		case 0xa5: // LDA ab
			ZPAGE();
			LDA_ZP();
			break;
		case 0xa6: // LDX ab
			ZPAGE();
			LDX_ZP();
			break;
		case 0xa8: // TAY
			nz = y = a;
			break;
		case 0xa9: // LDA #ab
			nz = a = FETCH();
			break;
		case 0xaa: // TAX
			nz = x = a;
			break;
		case 0xac: // LDY abcd
			ABSOLUTE();
			LDY();
			break;
		case 0xad: // LDA abcd
			ABSOLUTE();
			LDA();
			break;
		case 0xae: // LDX abcd
			ABSOLUTE();
			LDX();
			break;
		case 0xb0: // BCS
			BRANCH(c != 0);
		case 0xb1: // LDA (ab),y
			INDIRECT_Y();
			NCYCLES_Y();
			LDA();
			break;
		case 0xb4: // LDY ab,x
			ZPAGE_X();
			LDY_ZP();
			break;
		case 0xb5: // LDA ab,x
			ZPAGE_X();
			LDA_ZP();
			break;
		case 0xb6: // LDX ab,y
			ZPAGE_Y();
			LDX_ZP();
			break;
		case 0xb8: // CLV
			vdi &= CpuDFlag | CpuIFlag;
			break;
		case 0xb9: // LDA abcd,y
			ABSOLUTE_Y();
			NCYCLES_Y();
			LDA();
			break;
		case 0xba: // TSX
			nz = x = s;
			break;
		case 0xbc: // LDY abcd,x
			ABSOLUTE_X();
			NCYCLES_X();
			LDY();
			break;
		case 0xbd: // LDA abcd,x
			ABSOLUTE_X();
			NCYCLES_X();
			LDA();
			break;
		case 0xbe: // LDX abcd,y
			ABSOLUTE_Y();
			NCYCLES_Y();
			LDX();
			break;
		case 0xc0: // CPY #ab
			nz = FETCH();
			c = y >= nz ? 1 : 0;
			nz = (y - nz) & 0xff;
			break;
		case 0xc1: // CMP (ab,x)
			INDIRECT_X();
			CMP();
			break;
		case 0xc4: // CPY ab
			ZPAGE();
			CPY_ZP();
			break;
		case 0xc5: // CMP ab
			ZPAGE();
			CMP_ZP();
			break;
		case 0xc6: // DEC ab
			ZPAGE();
			DEC_ZP();
			break;
		case 0xc8: // INY
			nz = y = (y + 1) & 0xff;
			break;
		case 0xc9: // CMP #ab
			nz = FETCH();
			c = a >= nz ? 1 : 0;
			nz = (a - nz) & 0xff;
			break;
		case 0xca: // DEX
			nz = x = (x - 1) & 0xff;
			break;
		case 0xcc: // CPY abcd
			ABSOLUTE();
			CPY();
			break;
		case 0xcd: // CMP abcd
			ABSOLUTE();
			CMP();
			break;
		case 0xce: // DEC abcd
			ABSOLUTE();
			DEC();
			break;
		case 0xd0: // BNE
			BRANCH(nz & 0xff != 0);
		case 0xd1: // CMP (ab),y
			INDIRECT_Y();
			NCYCLES_Y();
			CMP();
			break;
		case 0xd5: // CMP ab,x
			ZPAGE_X();
			CMP_ZP();
			break;
		case 0xd6: // DEC ab,x
			ZPAGE_X();
			DEC_ZP();
			break;
		case 0xd8: // CLD
			vdi &= CpuVFlag | CpuIFlag;
			break;
		case 0xd9: // CMP abcd,y
			ABSOLUTE_Y();
			NCYCLES_Y();
			CMP();
			break;
		case 0xdd: // CMP abcd,x
			ABSOLUTE_X();
			NCYCLES_X();
			CMP();
			break;
		case 0xde: // DEC abcd,x
			ABSOLUTE_X();
			DEC();
			break;
		case 0xe0: // CPX #ab
			nz = FETCH();
			c = x >= nz ? 1 : 0;
			nz = (x - nz) & 0xff;
			break;
		case 0xe1: // SBC (ab,x)
			INDIRECT_X();
			SBC();
			break;
		case 0xe4: // CPX ab
			ZPAGE();
			CPX_ZP();
			break;
		case 0xe5: // SBC ab
			ZPAGE();
			SBC_ZP();
			break;
		case 0xe6: // INC ab
			ZPAGE();
			INC_ZP();
			break;
		case 0xe8: // INX
			nz = x = (x + 1) & 0xff;
			break;
		case 0xe9: // SBC #ab
		case 0xeb: // SBC #ab [unofficial]
			data = FETCH();
			DO_SBC();
			break;
		case 0xea: // NOP
		case 0x1a: // NOP [unofficial]
		case 0x3a:
		case 0x5a:
		case 0x7a:
		case 0xda:
		case 0xfa:
			break;
		case 0xec: // CPX abcd
			ABSOLUTE();
			CPX();
			break;
		case 0xed: // SBC abcd
			ABSOLUTE();
			SBC();
			break;
		case 0xee: // INC abcd
			ABSOLUTE();
			INC();
			break;
		case 0xf0: // BEQ
			BRANCH(nz & 0xff == 0);
		case 0xf1: // SBC (ab),y
			INDIRECT_Y();
			NCYCLES_Y();
			SBC();
			break;
		case 0xf5: // SBC ab,x
			ZPAGE_X();
			SBC_ZP();
			break;
		case 0xf6: // INC ab,x
			ZPAGE_X();
			INC_ZP();
			break;
		case 0xf8: // SED
			vdi |= CpuDFlag;
			break;
		case 0xf9: // SBC abcd,y
			ABSOLUTE_Y();
			NCYCLES_Y();
			SBC();
			break;
		case 0xfd: // SBC abcd,x
			ABSOLUTE_X();
			NCYCLES_X();
			SBC();
			break;
		case 0xfe: // INC abcd,x
			ABSOLUTE_X();
			INC();
			break;

#if !ACPU_NO_UNOFFICIAL
		case 0x03: // ASO (ab,x) [unofficial]
			INDIRECT_X();
			ASO();
			break;
		case 0x04: // NOP ab [unofficial]
		case 0x44:
		case 0x64:
		case 0x14: // NOP ab,x [unofficial]
		case 0x34:
		case 0x54:
		case 0x74:
		case 0xd4:
		case 0xf4:
		case 0x80: // NOP #ab [unofficial]
		case 0x82:
		case 0x89:
		case 0xc2:
		case 0xe2:
			pc++;
			break;
		case 0x07: // ASO ab [unofficial]
			ZPAGE();
			ASO_ZP();
			break;
		case 0x0b: // ANC #ab [unofficial]
		case 0x2b:
			nz = a &= FETCH();
			c = nz >> 7;
			break;
		case 0x0c: // NOP abcd [unofficial]
			pc += 2;
			break;
		case 0x0f: // ASO abcd [unofficial]
			ABSOLUTE();
			ASO();
			break;
		case 0x13: // ASO (ab),y [unofficial]
			INDIRECT_Y();
			ASO();
			break;
		case 0x17: // ASO ab,x [unofficial]
			ZPAGE_X();
			ASO_ZP();
			break;
		case 0x1b: // ASO abcd,y [unofficial]
			ABSOLUTE_Y();
			ASO();
			break;
		case 0x1c: // NOP abcd,x [unofficial]
		case 0x3c:
		case 0x5c:
		case 0x7c:
		case 0xdc:
		case 0xfc:
			if (FETCH() + x >= 0x100)
				ast.cycle++;
			pc++;
			break;
		case 0x1f: // ASO abcd,x [unofficial]
			ABSOLUTE_X();
			ASO();
			break;
		case 0x23: // RLA (ab,x) [unofficial]
			INDIRECT_X();
			RLA();
			break;
		case 0x27: // RLA ab [unofficial]
			ZPAGE();
			RLA_ZP();
			break;
		case 0x2f: // RLA abcd [unofficial]
			ABSOLUTE();
			RLA();
			break;
		case 0x33: // RLA (ab),y [unofficial]
			INDIRECT_Y();
			RLA();
			break;
		case 0x37: // RLA ab,x [unofficial]
			ZPAGE_X();
			RLA_ZP();
			break;
		case 0x3b: // RLA abcd,y [unofficial]
			ABSOLUTE_Y();
			RLA();
			break;
		case 0x3f: // RLA abcd,x [unofficial]
			ABSOLUTE_X();
			RLA();
			break;
		case 0x43: // LSE (ab,x) [unofficial]
			INDIRECT_X();
			LSE();
			break;
		case 0x47: // LSE ab [unofficial]
			ZPAGE();
			LSE_ZP();
			break;
		case 0x4b: // ALR #ab [unofficial]
			a &= FETCH();
			c = a & 1;
			nz = a >>= 1;
			break;
		case 0x4f: // LSE abcd [unofficial]
			ABSOLUTE();
			LSE();
			break;
		case 0x53: // LSE (ab),y [unofficial]
			INDIRECT_Y();
			LSE();
			break;
		case 0x57: // LSE ab,x [unofficial]
			ZPAGE_X();
			LSE_ZP();
			break;
		case 0x5b: // LSE abcd,y [unofficial]
			ABSOLUTE_Y();
			LSE();
			break;
		case 0x5f: // LSE abcd,x [unofficial]
			ABSOLUTE_X();
			LSE();
			break;
		case 0x63: // RRA (ab,x) [unofficial]
			INDIRECT_X();
			RRA();
			break;
		case 0x67: // RRA ab [unofficial]
			ZPAGE();
			RRA_ZP();
			break;
		case 0x6b: // ARR #ab [unofficial]
			data = a & FETCH();
			nz = a = (data >> 1) + (c << 7);
			vdi = (vdi & (CpuDFlag | CpuIFlag)) + ((a ^ data) & CpuVFlag);
#if ACPU_NO_DECIMAL
			c = data >> 7;
#else
			if (vdi & CpuDFlag == 0)
				c = data >> 7;
			else {
				if (data & 0xf >= 5)
					a = (a & 0xf0) + ((a + 6) & 0xf);
				if (data >= 0x50) {
					a = (a + 0x60) & 0xff;
					c = 1;
				}
				else
					c = 0;
			}
#endif
			break;
		case 0x6f: // RRA abcd [unofficial]
			ABSOLUTE();
			RRA();
			break;
		case 0x73: // RRA (ab),y [unofficial]
			INDIRECT_Y();
			RRA();
			break;
		case 0x77: // RRA ab,x [unofficial]
			ZPAGE_X();
			RRA_ZP();
			break;
		case 0x7b: // RRA abcd,y [unofficial]
			ABSOLUTE_Y();
			RRA();
			break;
		case 0x7f: // RRA abcd,x [unofficial]
			ABSOLUTE_X();
			RRA();
			break;
		case 0x83: // SAX (ab,x) [unofficial]
			INDIRECT_X();
			SAX();
			break;
		case 0x87: // SAX ab [unofficial]
			ZPAGE();
			SAX_ZP();
			break;
		case 0x8b: // ANE #ab [unofficial]
			data = FETCH();
			a &= (data | 0xef) & x;
			nz = a & data;
			break;
		case 0x8f: // SAX abcd [unofficial]
			ABSOLUTE();
			SAX();
			break;
		case 0x93: // SHA (ab),y [unofficial, unstable]
			{
				addr = FETCH();
				int hi = zGetByte(addr + 1);
				addr = dGetByte(addr);
				data = (hi + 1) & a & x;
				addr += y;
				if (addr >= 0x100)
					hi = data - 1;
				addr += hi << 8;
				PutByte(addr, data);
			}
			break;
		case 0x97: // SAX ab,y [unofficial]
			ZPAGE_Y();
			SAX_ZP();
			break;
		case 0x9b: // SHS abcd,y [unofficial, unstable]
			// S seems to be stable, only memory values vary
			s = a & x;
			SHX(s, y);
			break;
		case 0x9c: // SHY abcd,x [unofficial]
			SHX(y, x);
			break;
		case 0x9e: // SHX abcd,y [unofficial]
			SHX(x, y);
			break;
		case 0x9f: // SHA abcd,y [unofficial, unstable]
			SHX(a & x, y);
			break;
		case 0xa3: // LAX (ab,x) [unofficial]
			INDIRECT_X();
			LAX();
			break;
		case 0xa7: // LAX ab [unofficial]
			ZPAGE();
			LAX_ZP();
			break;
		case 0xab: // ANX #ab [unofficial]
			nz = x = a &= FETCH();
			break;
		case 0xaf: // LAX abcd [unofficial]
			ABSOLUTE();
			LAX();
			break;
		case 0xb3: // LAX (ab),y [unofficial]
			INDIRECT_Y();
			NCYCLES_Y();
			LAX();
			break;
		case 0xb7: // LAX ab,y [unofficial]
			ZPAGE_Y();
			LAX_ZP();
			break;
		case 0xbb: // LAS abcd,y [unofficial, unstable]
			// only Z is unstable
			ABSOLUTE_Y();
			NCYCLES_Y();
			nz = x = a = s &= GetByte(addr);
			break;
		case 0xbf: // LAX abcd,y [unofficial]
			ABSOLUTE_Y();
			NCYCLES_Y();
			LAX();
			break;
		case 0xc3: // DCM (ab,x) [unofficial]
			INDIRECT_X();
			DCM();
			break;
		case 0xc7: // DCM ab [unofficial]
			ZPAGE();
			DCM_ZP();
			break;
		case 0xcb: // SBX #ab [unofficial]
			nz = FETCH();
			x &= a;
			c = x >= nz ? 1 : 0;
			nz = x = (x - nz) & 0xff;
			break;
		case 0xcf: // DCM abcd [unofficial]
			ABSOLUTE();
			DCM();
			break;
		case 0xd3: // DCM (ab),y [unofficial]
			INDIRECT_Y();
			DCM();
			break;
		case 0xd7: // DCM ab,x [unofficial]
			ZPAGE_X();
			DCM_ZP();
			break;
		case 0xdb: // DCM abcd,y [unofficial]
			ABSOLUTE_Y();
			DCM();
			break;
		case 0xdf: // DCM abcd,x [unofficial]
			ABSOLUTE_X();
			DCM();
			break;
		case 0xe3: // INS (ab,x) [unofficial]
			INDIRECT_X();
			INS();
			break;
		case 0xe7: // INS ab [unofficial]
			ZPAGE();
			INS_ZP();
			break;
		case 0xef: // INS abcd [unofficial]
			ABSOLUTE();
			INS();
			break;
		case 0xf3: // INS (ab),y [unofficial]
			INDIRECT_Y();
			INS();
			break;
		case 0xf7: // INS ab,x [unofficial]
			ZPAGE_X();
			INS_ZP();
			break;
		case 0xfb: // INS abcd,y [unofficial]
			ABSOLUTE_Y();
			INS();
			break;
		case 0xff: // INS abcd,x [unofficial]
			ABSOLUTE_X();
			INS();
			break;
#endif // ACPU_NO_UNOFFICIAL
		}
	}
	ast.cpu_pc = pc;
	ast.cpu_nz = nz;
	ast.cpu_a = a;
	ast.cpu_x = x;
	ast.cpu_y = y;
	ast.cpu_c = c;
	ast.cpu_s = s;
	ast.cpu_vdi = vdi;
	ast.cycle -= cycle_limit;
	if (ast.timer1_cycle != NeverCycle)
		ast.timer1_cycle -= cycle_limit;
	if (ast.timer2_cycle != NeverCycle)
		ast.timer2_cycle -= cycle_limit;
	if (ast.timer4_cycle != NeverCycle)
		ast.timer4_cycle -= cycle_limit;
}

// 6502 player types
// TODO: enum
const int TypeSAP_B = 1;
const int TypeSAP_C = 2;
const int TypeSAP_D = 3;
const int TypeSAP_S = 4;
const int TypeCMC   = 5;
const int TypeCM3   = 6;
const int TypeCMR   = 7;
const int TypeCMS   = 8;
const int TypeDLT   = 9;
const int TypeMPT   = 10;
const int TypeRMT   = 11;
const int TypeTMC   = 12;
const int TypeTM2   = 13;

int uword(byte[] array, int i)
{
	return array[i] + array[i + 1] << 8;
}

/// Loads a native module (anything except SAP) and a 6502 player routine.
bool load_native(ASAP_State ast, ASAP_ModuleInfo module_info, byte[] module, int module_len, byte[] player)
{
	if ((module[0] != 0xff || module[1] != 0xff)
	 && (module[0] != 0 || module[1] != 0)) // some CMC and clones start with zeros
		return false;
	module_info.music = uword(module, 2);
#if !ASAP_ONLY_INFO
	module_info.player = uword(player, 2);
	int player_last_byte = uword(player, 4);
	if (module_info.music <= player_last_byte)
		return false;
#endif
	int music_last_byte = uword(module, 4);
	if (module_info.music <= 0xd7ff && music_last_byte >= 0xd000)
		return false;
	int block_len = music_last_byte + 1 - module_info.music;
	if (6 + block_len != module_len) {
		if (module_info.type != TypeRMT || 11 + block_len > module_len)
			return false;
		// allow optional info for Raster Music Tracker
		int info_addr = uword(module, 6 + block_len);
		if (info_addr != module_info.music + block_len)
			return false;
		int info_len = uword(module, 8 + block_len) + 1 - info_addr;
		if (10 + block_len + info_len != module_len)
			return false;
	}
#if !ASAP_ONLY_INFO
	if (ast != null) {
		module.CopyTo(6, ast.memory, module_info.music, block_len);
		player.CopyTo(6, ast.memory, module_info.player, player_last_byte + 1 - module_info.player);
	}
#endif
	return true;
}

void set_song_duration(ASAP_ModuleInfo module_info, int player_calls)
{
	module_info.durations[module_info.songs] = (player_calls * module_info.fastplay).MulDiv(114000, 1773447);
	module_info.songs++;
}

// TODO
macro GET_PLAYER(name)  (null)

// TODO: enum + 0
const int SeenThisCall = 1;
const int SeenBefore   = 2;
const int SeenRepeat   = 3;

void parse_cmc_song(ASAP_ModuleInfo module_info, byte[] module, int pos)
{
	int tempo = module[0x19];
	int player_calls = 0;
	int rep_start_pos = 0;
	int rep_end_pos = 0;
	int rep_times = 0;
	byte[0x55] seen = 0;
	while (pos >= 0 && pos < 0x55) {
		if (pos == rep_end_pos && rep_times > 0) {
			for (int i = 0; i < 0x55; i++)
				if (seen[i] == SeenThisCall || seen[i] == SeenRepeat)
					seen[i] = 0;
			rep_times--;
			pos = rep_start_pos;
		}
		if (seen[pos] != 0) {
			if (seen[pos] != SeenThisCall)
				module_info.loops[module_info.songs] = true;
			break;
		}
		seen[pos] = SeenThisCall;
		int p1 = module[0x206 + pos];
		int p2 = module[0x25b + pos];
		int p3 = module[0x2b0 + pos];
		if (p1 == 0xfe || p2 == 0xfe || p3 == 0xfe) {
			pos++;
			continue;
		}
		p1 >>= 4;
		if (p1 == 8)
			break;
		if (p1 == 9) {
			pos = p2;
			continue;
		}
		if (p1 == 0xa) {
			pos -= p2;
			continue;
		}
		if (p1 == 0xb) {
			pos += p2;
			continue;
		}
		if (p1 == 0xc) {
			tempo = p2;
			pos++;
			continue;
		}
		if (p1 == 0xd) {
			pos++;
			rep_start_pos = pos;
			rep_end_pos = pos + p2;
			rep_times = p3 - 1;
			continue;
		}
		if (p1 == 0xe) {
			module_info.loops[module_info.songs] = true;
			break;
		}
		p2 = rep_times > 0 ? SeenRepeat : SeenBefore;
		for (p1 = 0; p1 < 0x55; p1++)
			if (seen[p1] == SeenThisCall)
				seen[p1] = p2;
		player_calls += tempo * (module_info.type == TypeCM3 ? 48 : 64);
		pos++;
	}
	set_song_duration(module_info, player_calls);
}

const int CMRBassTableOffset = 0x70f;

bool parse_cmc(ASAP_State ast, ASAP_ModuleInfo module_info, byte[] module, int module_len, int type, byte[] player)
{
	if (module_len < 0x306)
		return false;
	module_info.type = type;
	if (!load_native(ast, module_info, module, module_len, player))
		return false;
#if !ASAP_ONLY_INFO
	if (ast != null && type == TypeCMR) {
		const byte[] cmr_bass_table = {
			0x5c, 0x56, 0x50, 0x4d, 0x47, 0x44, 0x41, 0x3e,
			0x38, 0x35, 0x88, 0x7f, 0x79, 0x73, 0x6c, 0x67,
			0x60, 0x5a, 0x55, 0x51, 0x4c, 0x48, 0x43, 0x3f,
			0x3d, 0x39, 0x34, 0x33, 0x30, 0x2d, 0x2a, 0x28,
			0x25, 0x24, 0x21, 0x1f, 0x1e
		};
//TODO		cmr_bass_table.CopyTo(0, ast.memory, 0x500 + CMRBassTableOffset, cmr_bass_table.Length);
	}
#endif
	int last_pos = 0x54;
	while (--last_pos >= 0) {
		if (module[0x206 + last_pos] < 0xb0
		 || module[0x25b + last_pos] < 0x40
		 || module[0x2b0 + last_pos] < 0x40)
			break;
		if (module_info.channels == 2) {
			if (module[0x306 + last_pos] < 0xb0
			 || module[0x35b + last_pos] < 0x40
			 || module[0x3b0 + last_pos] < 0x40)
				break;
		}
	}
	module_info.songs = 0;
	parse_cmc_song(module_info, module, 0);
	for (int pos = 0; pos < last_pos && module_info.songs < SongsMax; pos++)
		if (module[0x206 + pos] == 0x8f || module[0x206 + pos] == 0xef)
			parse_cmc_song(module_info, module, pos + 1);
	return true;
}

bool is_dlt_track_empty(byte[] module, int pos)
{
	return module[0x2006 + pos] >= 0x43
		&& module[0x2106 + pos] >= 0x40
		&& module[0x2206 + pos] >= 0x40
		&& module[0x2306 + pos] >= 0x40;
}

bool is_dlt_pattern_end(byte[] module, int pos, int i)
{
	for (int ch = 0; ch < 4; ch++) {
		int pattern = module[0x2006 + ch << 8 + pos];
		if (pattern < 64) {
			int offset = 6 + pattern << 7 + i << 1;
			if (module[offset] & 0x80 == 0 && module[offset + 1] & 0x80 != 0)
				return true;
		}
	}
	return false;
}

void parse_dlt_song(ASAP_ModuleInfo module_info, byte[] module, bool[] seen, int pos)
{
	while (pos < 128 && !seen[pos] && is_dlt_track_empty(module, pos))
		seen[pos++] = true;
	module_info.song_pos[module_info.songs] = pos;
	int player_calls = 0;
	bool loop = false;
	int tempo = 6;
	while (pos < 128) {
		if (seen[pos]) {
			loop = true;
			break;
		}
		seen[pos] = true;
		int p1 = module[0x2006 + pos];
		if (p1 == 0x40 || is_dlt_track_empty(module, pos))
			break;
		if (p1 == 0x41)
			pos = module[0x2086 + pos];
		else if (p1 == 0x42)
			tempo = module[0x2086 + pos++];
		else {
			for (int i = 0; i < 64 && !is_dlt_pattern_end(module, pos, i); i++)
				player_calls += tempo;
			pos++;
		}
	}
	if (player_calls > 0) {
		module_info.loops[module_info.songs] = loop;
		set_song_duration(module_info, player_calls);
	}
}

bool parse_dlt(ASAP_State ast, ASAP_ModuleInfo module_info, byte[] module, int module_len)
{
	if (module_len == 0x2c06) {
		if (ast != null)
			ast.memory[0x4c00] = 0;
	}
	else if (module_len != 0x2c07)
		return false;
	module_info.type = TypeDLT;
	if (!load_native(ast, module_info, module, module_len, GET_PLAYER("dlt"))
	 || module_info.music != 0x2000)
		return false;
	bool[128] seen = false;
	module_info.songs = 0;
	for (int pos = 0; pos < 128 && module_info.songs < SongsMax; pos++) {
		if (!seen[pos])
			parse_dlt_song(module_info, module, seen, pos);
	}
	return module_info.songs > 0;
}

void parse_mpt_song(ASAP_ModuleInfo module_info, byte[] module, bool[] global_seen, int song_len, int pos)
{
	int addr_to_offset = uword(module, 2) - 6;
	int tempo = module[0x1cf];
	int player_calls = 0;
	byte[256] seen = 0;
	int[4] pattern_offset;
	int[4] blank_rows = 0;
	int[4] blank_rows_counter;
	while (pos < song_len) {
		if (seen[pos] != 0) {
			if (seen[pos] != SeenThisCall)
				module_info.loops[module_info.songs] = true;
			break;
		}
		seen[pos] = SeenThisCall;
		global_seen[pos] = true;
		int i = module[0x1d0 + pos * 2];
		if (i == 0xff) {
			pos = module[0x1d1 + pos * 2];
			continue;
		}
		int ch;
		for (ch = 3; ch >= 0; ch--) {
			i = module[0x1c6 + ch] + module[0x1ca + ch] << 8 - addr_to_offset;
			i = module[i + pos * 2];
			if (i >= 0x40)
				break;
			i <<= 1;
			i = uword(module, 0x46 + i);
			pattern_offset[ch] = i == 0 ? 0 : i - addr_to_offset;
			blank_rows_counter[ch] = 0;
		}
		if (ch >= 0)
			break;
		for (i = 0; i < song_len; i++)
			if (seen[i] == SeenThisCall)
				seen[i] = SeenBefore;
		for (int pattern_rows = module[0x1ce]; --pattern_rows >= 0; ) {
			for (ch = 3; ch >= 0; ch--) {
				if (pattern_offset[ch] == 0 || --blank_rows_counter[ch] >= 0)
					continue;
				for (;;) {
					i = module[pattern_offset[ch]++];
					if (i < 0x40 || i == 0xfe)
						break;
					if (i < 0x80)
						continue;
					if (i < 0xc0) {
						blank_rows[ch] = i - 0x80;
						continue;
					}
					if (i < 0xd0)
						continue;
					if (i < 0xe0) {
						tempo = i - 0xcf;
						continue;
					}
					pattern_rows = 0;
				}
				blank_rows_counter[ch] = blank_rows[ch];
			}
			player_calls += tempo;
		}
		pos++;
	}
	if (player_calls > 0)
		set_song_duration(module_info, player_calls);
}

bool parse_mpt(ASAP_State ast, ASAP_ModuleInfo module_info, byte[] module, int module_len)
{
	if (module_len < 0x1d0)
		return false;
	module_info.type = TypeMPT;
	if (!load_native(ast, module_info, module, module_len, GET_PLAYER("mpt")))
		return false;
	int track0_addr = uword(module, 2) + 0x1ca;
	if (module[0x1c6] + module[0x1ca] << 8 != track0_addr)
		return false;
	// Calculate the length of the first track. Address of the second track minus
	// address of the first track equals the length of the first track in bytes.
	// Divide by two to get number of track positions.
	int song_len = (module[0x1c7] + module[0x1cb] << 8 - track0_addr) >> 1;
	if (song_len > 0xfe)
		return false;
	// `global_seen[i] == true` if the track position `i` has been processed
	bool[256] global_seen = false;
	module_info.songs = 0;
	for (int pos = 0; pos < song_len && module_info.songs < SongsMax; pos++) {
		if (!global_seen[pos]) {
			module_info.song_pos[module_info.songs] = pos;
			parse_mpt_song(module_info, module, global_seen, song_len, pos);
		}
	}
	return module_info.songs > 0;
}

int rmt_instrument_frames(byte[] module, int instrument, int volume, int volume_frame, bool extra_pokey)
{
	int addr_to_offset = uword(module, 2) - 6;
	instrument = uword(module, 0xe) - addr_to_offset + instrument << 1;
	if (module[instrument + 1] == 0)
		return 0;
	instrument = uword(module, instrument) - addr_to_offset;
	int per_frame = module[0xc];
	int player_call = volume_frame * per_frame;
	int player_calls = player_call;
	int index = module[instrument] + 1 + player_call * 3;
	int index_end = module[instrument + 2] + 3;
	int index_loop = module[instrument + 3];
	if (index_loop >= index_end)
		return 0; // error
	int volume_slide_depth = module[instrument + 6];
	int volume_min = module[instrument + 7];
	const byte[] rmt_volume_silent = { 16, 8, 4, 3, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1 };
	if (index >= index_end)
		index = (index - index_end) % (index_end - index_loop) + index_loop;
	else {
		do {
			int vol = module[instrument + index];
			if (extra_pokey)
				vol >>= 4;
			if (vol & 0xf >= rmt_volume_silent[volume])
				player_calls = player_call + 1;
			player_call++;
			index += 3;
		} while (index < index_end);
	}
	if (volume_slide_depth == 0)
		return player_calls / per_frame;
	int volume_slide = 128;
	bool silent_loop = false;
	for (;;) {
		if (index >= index_end) {
			if (silent_loop)
				break;
			silent_loop = true;
			index = index_loop;
		}
		int vol = module[instrument + index];
		if (extra_pokey)
			vol >>= 4;
		if (vol & 0xf >= rmt_volume_silent[volume]) {
			player_calls = player_call + 1;
			silent_loop = false;
		}
		player_call++;
		index += 3;
		volume_slide -= volume_slide_depth;
		if (volume_slide < 0) {
			volume_slide += 256;
			if (--volume <= volume_min)
				break;
		}
	}
	return player_calls / per_frame;
}

void parse_rmt_song(ASAP_ModuleInfo module_info, byte[] module, bool[] global_seen, int song_len, int pos_shift, int pos)
{
	int addr_to_offset = uword(module, 2) - 6;
	int tempo = module[0xb];
	int frames = 0;
	int song_offset = uword(module, 0x14) - addr_to_offset;
	int pattern_lo_offset = uword(module, 0x10) - addr_to_offset;
	int pattern_hi_offset = uword(module, 0x12) - addr_to_offset;
	byte[256] seen = false;
	int[8] pattern_begin;
	int[8] pattern_offset;
	int[8] blank_rows;
	int[8] instrument_no = 0;
	int[8] instrument_frame = 0;
	int[8] volume_value = 0;
	int[8] volume_frame = 0;
	while (pos < song_len) {
		if (seen[pos] != 0) {
			if (seen[pos] != SeenThisCall)
				module_info.loops[module_info.songs] = true;
			break;
		}
		seen[pos] = SeenThisCall;
		global_seen[pos] = true;
		if (module[song_offset + pos << pos_shift] == 0xfe) {
			pos = module[song_offset + pos << pos_shift + 1];
			continue;
		}
		for (int ch = 0; ch < 1 << pos_shift; ch++) {
			int p = module[song_offset + pos << pos_shift + ch];
			if (p == 0xff)
				blank_rows[ch] = 256;
			else {
				pattern_offset[ch] = pattern_begin[ch] = module[pattern_lo_offset + p]
					+ module[pattern_hi_offset + p] << 8 - addr_to_offset;
				blank_rows[ch] = 0;
			}
		}
		for (int i = 0; i < song_len; i++)
			if (seen[i] == SeenThisCall)
				seen[i] = SeenBefore;
		for (int pattern_rows = module[0xa]; --pattern_rows >= 0; ) {
			for (int ch = 0; ch < 1 << pos_shift; ch++) {
				if (--blank_rows[ch] > 0)
					continue;
				for (;;) {
					int i = module[pattern_offset[ch]++];
					if (i & 0x3f < 62) {
						i += module[pattern_offset[ch]++] << 8;
						if (i & 0x3f != 61) {
							instrument_no[ch] = i >> 10;
							instrument_frame[ch] = frames;
						}
						volume_value[ch] = (i >> 6) & 0xf;
						volume_frame[ch] = frames;
						break;
					}
					if (i == 62) {
						blank_rows[ch] = module[pattern_offset[ch]++];
						break;
					}
					if ((i & 0x3f) == 62) {
						blank_rows[ch] = i >> 6;
						break;
					}
					if ((i & 0xbf) == 63) {
						tempo = module[pattern_offset[ch]++];
						continue;
					}
					if (i == 0xbf) {
						pattern_offset[ch] = pattern_begin[ch] + module[pattern_offset[ch]];
						continue;
					}
					// assert(i == 0xff);
					pattern_rows = -1;
					break;
				}
				if (pattern_rows < 0)
					break;
			}
			if (pattern_rows >= 0)
				frames += tempo;
		}
		pos++;
	}
	int instrument_frames = 0;
	for (int ch = 0; ch < 1 << pos_shift; ch++) {
		int frame = instrument_frame[ch];
		frame += rmt_instrument_frames(module, instrument_no[ch], volume_value[ch], volume_frame[ch] - frame, ch >= 4);
		if (instrument_frames < frame)
			instrument_frames = frame;
	}
	if (frames > instrument_frames) {
		if (frames - instrument_frames > 100)
			module_info.loops[module_info.songs] = false;
		frames = instrument_frames;
	}
	if (frames > 0)
		set_song_duration(module_info, frames);
}

bool parse_rmt(ASAP_State ast, ASAP_ModuleInfo module_info, byte[] module, int module_len)
{
	if (module_len < 0x30 || module[6] != 'R' || module[7] != 'M' || module[8] != 'T' || module[0xd] != 1)
		return false;
	int pos_shift;
	switch (module[9]) {
	case '4':
		pos_shift = 2;
		break;
	case '8':
		module_info.channels = 2;
		pos_shift = 3;
		break;
	default:
		return false;
	}
	int per_frame = module[0xc];
	if (per_frame < 1 || per_frame > 4)
		return false;
	module_info.type = TypeRMT;
	if (!load_native(ast, module_info, module, module_len, module_info.channels == 2 ? GET_PLAYER("rmt8") : GET_PLAYER("rmt4")))
		return false;
	int song_len = uword(module, 4) + 1 - uword(module, 0x14);
	if (pos_shift == 3 && song_len & 4 != 0 && module[6 + uword(module, 4) - uword(module, 2) - 3] == 0xfe)
		song_len += 4;
	song_len >>= pos_shift;
	if (song_len >= 0x100)
		return false;
	bool[256] global_seen = false;
	module_info.songs = 0;
	for (int pos = 0; pos < song_len && module_info.songs < SongsMax; pos++) {
		if (!global_seen[pos]) {
			module_info.song_pos[module_info.songs] = pos;
			parse_rmt_song(module_info, module, global_seen, song_len, pos_shift, pos);
		}
	}
	// must set fastplay after song durations calculations, so they assume 312
	module_info.fastplay = 312 / per_frame;
	module_info.player = 0x600;
	return module_info.songs > 0;
}

void parse_tmc_song(ASAP_ModuleInfo module_info, byte[] module, int pos)
{
	int addr_to_offset = uword(module, 2) - 6;
	int tempo = module[0x24] + 1;
	int frames = 0;
	int[8] pattern_offset;
	int[8] blank_rows;
	while (module[0x1a6 + 15 + pos] < 0x80) {
		for (int ch = 7; ch >= 0; ch--) {
			int pat = module[0x1a6 + 15 + pos - 2 * ch];
			pattern_offset[ch] = module[0xa6 + pat] + module[0x126 + pat] << 8 - addr_to_offset;
			blank_rows[ch] = 0;
		}
		for (int pattern_rows = 64; --pattern_rows >= 0; ) {
			for (int ch = 7; ch >= 0; ch--) {
				if (--blank_rows[ch] >= 0)
					continue;
				for (;;) {
					int i = module[pattern_offset[ch]++];
					if (i < 0x40) {
						pattern_offset[ch]++;
						break;
					}
					if (i == 0x40) {
						i = module[pattern_offset[ch]++];
						if (i & 0x7f == 0)
							pattern_rows = 0;
						else
							tempo = i & 0x7f + 1;
						if (i >= 0x80)
							pattern_offset[ch]++;
						break;
					}
					if (i < 0x80) {
						i = module[pattern_offset[ch]++] & 0x7f;
						if (i == 0)
							pattern_rows = 0;
						else
							tempo = i + 1;
						pattern_offset[ch]++;
						break;
					}
					if (i < 0xc0)
						continue;
					blank_rows[ch] = i - 0xbf;
					break;
				}
			}
			frames += tempo;
		}
		pos += 16;
	}
	if (module[0x1a6 + 14 + pos] < 0x80)
		module_info.loops[module_info.songs] = true;
	set_song_duration(module_info, frames);
}

bool parse_tmc(ASAP_State ast, ASAP_ModuleInfo module_info, byte[] module, int module_len)
{
	if (module_len < 0x1d0)
		return false;
	module_info.type = TypeTMC;
	if (!load_native(ast, module_info, module, module_len, GET_PLAYER("tmc")))
		return false;
	module_info.channels = 2;
	int i = 0;
	// find first instrument
	while (module[0x66 + i] == 0) {
		if (++i >= 64)
			return false; // no instrument
	}
	int last_pos = module[0x66 + i] << 8 + module[0x26 + i] - uword(module, 2) - 0x1b0;
	if (0x1b5 + last_pos >= module_len)
		return false;
	// skip trailing jumps
	do {
		if (last_pos <= 0)
			return false; // no pattern to play
		last_pos -= 16;
	} while (module[0x1b5 + last_pos] >= 0x80);
	module_info.songs = 0;
	parse_tmc_song(module_info, module, 0);
	for (i = 0; i < last_pos && module_info.songs < SongsMax; i += 16)
		if (module[0x1b5 + i] >= 0x80)
			parse_tmc_song(module_info, module, i + 16);
	// must set fastplay after song durations calculations, so they assume 312
	i = module[0x25];
	if (i < 1 || i > 4)
		return false;
	if (ast != null)
		ast.tmc_per_frame = i;
	module_info.fastplay = 312 / i;
	return true;
}

void parse_tm2_song(ASAP_ModuleInfo module_info, byte[] module, int pos)
{
	int addr_to_offset = uword(module, 2) - 6;
	int tempo = module[0x24] + 1;
	int player_calls = 0;
	int[8] pattern_offset;
	int[8] blank_rows;
	for (;;) {
		int pattern_rows = module[0x386 + 16 + pos];
		if (pattern_rows == 0)
			break;
		if (pattern_rows >= 0x80) {
			module_info.loops[module_info.songs] = true;
			break;
		}
		for (int ch = 7; ch >= 0; ch--) {
			int pat = module[0x386 + 15 + pos - 2 * ch];
			pattern_offset[ch] = module[0x106 + pat] + module[0x206 + pat] << 8 - addr_to_offset;
			blank_rows[ch] = 0;
		}
		while (--pattern_rows >= 0) {
			for (int ch = 7; ch >= 0; ch--) {
				if (--blank_rows[ch] >= 0)
					continue;
				for (;;) {
					int i = module[pattern_offset[ch]++];
					if (i == 0) {
						pattern_offset[ch]++;
						break;
					}
					if (i < 0x40) {
						if (module[pattern_offset[ch]++] >= 0x80)
							pattern_offset[ch]++;
						break;
					}
					if (i < 0x80) {
						pattern_offset[ch]++;
						break;
					}
					if (i == 0x80) {
						blank_rows[ch] = module[pattern_offset[ch]++];
						break;
					}
					if (i < 0xc0)
						break;
					if (i < 0xd0) {
						tempo = i - 0xbf;
						continue;
					}
					if (i < 0xe0) {
						pattern_offset[ch]++;
						break;
					}
					if (i < 0xf0) {
						pattern_offset[ch] += 2;
						break;
					}
					if (i < 0xff) {
						blank_rows[ch] = i - 0xf0;
						break;
					}
					blank_rows[ch] = 64;
					break;
				}
			}
			player_calls += tempo;
		}
		pos += 17;
	}
	set_song_duration(module_info, player_calls);
}

bool parse_tm2(ASAP_State ast, ASAP_ModuleInfo module_info, byte[] module, int module_len)
{
	if (module_len < 0x3a4)
		return false;
	module_info.type = TypeTM2;
	if (!load_native(ast, module_info, module, module_len, GET_PLAYER("tm2")))
		return false;
	int i = module[0x25];
	if (i < 1 || i > 4)
		return false;
	module_info.fastplay = 312 / i;
	module_info.player = 0x500;
	if (module[0x1f] != 0)
		module_info.channels = 2;
	int last_pos = 0xffff;
	for (i = 0; i < 0x80; i++) {
		int instr_addr = module[0x86 + i] + module[0x306 + i] << 8;
		if (instr_addr != 0 && instr_addr < last_pos)
			last_pos = instr_addr;
	}
	for (i = 0; i < 0x100; i++) {
		int pattern_addr = module[0x106 + i] + module[0x206 + i] << 8;
		if (pattern_addr != 0 && pattern_addr < last_pos)
			last_pos = pattern_addr;
	}
	last_pos -= uword(module, 2) + 0x380;
	if (0x386 + last_pos >= module_len)
		return false;
	// skip trailing stop/jump commands
	int c;
	do {
		if (last_pos <= 0)
			return false;
		last_pos -= 17;
		c = module[0x386 + 16 + last_pos];
	} while (c == 0 || c >= 0x80);
	module_info.songs = 0;
	parse_tm2_song(module_info, module, 0);
	for (i = 0; i < last_pos && module_info.songs < SongsMax; i += 17) {
		c = module[0x386 + 16 + i];
		if (c == 0 || c >= 0x80)
			parse_tm2_song(module_info, module, i + 17);
	}
	return true;
}

bool has_string_at(byte[] module, int module_index, string s)
{
	int n = s.Length;
	for (int i = 0; i < n; i++)
		if (module[module_index + i] != s[i])
			return false;
	return true;
}

int parse_text(byte[] module, int module_index)
{
	if (module[module_index] != '"')
		return -1;
	if (has_string_at(module, module_index + 1, "<?>\"\r"))
		return 0;
	for (int len = 0; ; len++) {
		int c = module[module_index + 1 + len];
		if (c == '"') {
			if (module[module_index + 2 + len] != '\r')
				return -1;
			return len;
		}
		if (c < 32 || c >= 127)
			return -1;
	}
}

int parse_dec(byte[] module, int module_index, int maxval)
{
	if (module[module_index] == '\r')
		return -1;
	for (int r = 0;;) {
		int c = module[module_index++];
		if (c == '\r')
			return r;
		if (c < '0' || c > '9')
			return -1;
		r = 10 * r + c - '0';
		if (r > maxval)
			return -1;
	}
}

int parse_hex(byte[] module, int module_index)
{
	if (module[module_index] == '\r')
		return -1;
	for (int r = 0;;) {
		int c = module[module_index++];
		if (c == '\r')
			return r;
		if (r > 0xfff)
			return -1;
		r <<= 4;
		if (c >= '0' && c <= '9')
			r += c - '0';
		else if (c >= 'A' && c <= 'F')
			r += c - 'A' + 10;
		else if (c >= 'a' && c <= 'f')
			r += c - 'a' + 10;
		else
			return -1;
	}
}

public int ASAP_ParseDuration(string s)
{
	int i = 0;
	int n = s.Length;
	int d;
	macro PARSE_DIGIT(maxdig, retifnot) {
		if (i >= n)
			return retifnot;
		d = s[i] - '0';
		if (d < 0 || d > maxdig)
			return -1;
		i++;
	}
	PARSE_DIGIT(9, -1);
	int r = d;
	if (i < n) {
		d = s[i] - '0';
		if (d >= 0 && d <= 9) {
			i++;
			r = 10 * r + d;
		}
		if (i < n && s[i] == ':') {
			i++;
			PARSE_DIGIT(5, -1);
			r = (6 * r + d) * 10;
			PARSE_DIGIT(9, -1);
			r += d;
		}
	}
	r *= 1000;
	if (i >= n)
		return r;
	if (s[i] != '.')
		return -1;
	i++;
	PARSE_DIGIT(9, -1);
	r += 100 * d;
	PARSE_DIGIT(9, r);
	r += 10 * d;
	PARSE_DIGIT(9, r);
	r += d;
	return r;
}

bool parse_sap_header(ASAP_ModuleInfo module_info, byte[] module, int module_len)
{
	if (!has_string_at(module, 0, "SAP\r\n"))
		return false;
	module_info.fastplay = -1;
	int type = 0;
	int module_index = 5;
	int duration_index = 0;
	while (module[module_index] != 0xff) {
		if (module_index + 8 >= module_len)
			return false;
		macro TAG_IS(s)               ( has_string_at(module, module_index, s) )
		macro SET_TEXT(v, i) {
			int len = parse_text(module, module_index + i);
			if (len < 0)
				return false;
			if (len > 0)
				v = module.ToString(module_index + i + 1, len);
		}
		macro SET_DEC(v, i, min, max) { v = parse_dec(module, module_index + i, max); if (v < min) return false; }
		macro SET_HEX(v, i)           { v = parse_hex(module, module_index + i); }
		if (TAG_IS("AUTHOR ")) {
			SET_TEXT(module_info.author, 7);
		}
		else if (TAG_IS("NAME ")) {
			SET_TEXT(module_info.name, 5);
		}
		else if (TAG_IS("DATE ")) {
			SET_TEXT(module_info.date, 5);
		}
		else if (TAG_IS("SONGS ")) {
			SET_DEC(module_info.songs, 6, 1, SongsMax);
		}
		else if (TAG_IS("DEFSONG ")) {
			SET_DEC(module_info.default_song, 8, 0, SongsMax - 1);
		}
		else if (TAG_IS("STEREO\r"))
			module_info.channels = 2;
		else if (TAG_IS("NTSC\r"))
			module_info.ntsc = true;
		else if (TAG_IS("TIME ")) {
			if (duration_index >= SongsMax)
				return false;
			module_index += 5;
			int len;
			for (len = 0; module[module_index + len] != '\r'; len++) { }
			if (len > 5 && has_string_at(module, module_index + len - 5, " LOOP")) {
				module_info.loops[duration_index] = true;
				len -= 5;
			}
			if (len > 9)
				return false;
			string(9) s = module.ToString(module_index, len);
			int i = ASAP_ParseDuration(s);
			if (i < 0)
				return false;
			module_info.durations[duration_index++] = i;
		}
		else if (TAG_IS("TYPE "))
			type = module[module_index + 5];
		else if (TAG_IS("FASTPLAY ")) {
			SET_DEC(module_info.fastplay, 9, 1, 312);
		}
		else if (TAG_IS("MUSIC ")) {
			SET_HEX(module_info.music, 6);
		}
		else if (TAG_IS("INIT ")) {
			SET_HEX(module_info.init, 5);
		}
		else if (TAG_IS("PLAYER ")) {
			SET_HEX(module_info.player, 7);
		}
		else if (TAG_IS("COVOX ")) {
			SET_HEX(module_info.covox_addr, 6);
			if (module_info.covox_addr != 0xd600)
				return false;
			module_info.channels = 2;
		}

		while (module[module_index++] != '\r') {
			if (module_index >= module_len)
				return false;
		}
		if (module[module_index++] != '\n')
			return false;
	}
	if (module_info.default_song >= module_info.songs)
		return false;
	switch (type) {
	case 'B':
		if (module_info.player < 0 || module_info.init < 0)
			return false;
		module_info.type = TypeSAP_B;
		break;
	case 'C':
		if (module_info.player < 0 || module_info.music < 0)
			return false;
		module_info.type = TypeSAP_C;
		break;
	case 'D':
		if (module_info.init < 0)
			return false;
		module_info.type = TypeSAP_D;
		break;
	case 'S':
		if (module_info.init < 0)
			return false;
		module_info.type = TypeSAP_S;
		module_info.fastplay = 78;
		break;
	default:
		return false;
	}
	if (module_info.fastplay < 0)
		module_info.fastplay = module_info.ntsc ? 262 : 312;
	else if (module_info.ntsc && module_info.fastplay > 262)
		return false;
	if (module[module_index + 1] != 0xff)
		return false;
	module_info.header_len = module_index;
	return true;
}

bool parse_sap(ASAP_State ast, ASAP_ModuleInfo module_info, byte[] module, int module_len)
{
	if (!parse_sap_header(module_info, module, module_len))
		return false;
	if (ast == null)
		return true;
	ast.memory.Clear();
	int module_index = module_info.header_len + 2;
	while (module_index + 5 <= module_len) {
		int start_addr = uword(module, module_index);
		int block_len = uword(module, module_index + 2) + 1 - start_addr;
		if (block_len <= 0 || module_index + block_len > module_len)
			return false;
		module_index += 4;
		module.CopyTo(module_index, ast.memory, start_addr, block_len);
		module_index += block_len;
		if (module_index == module_len)
			return true;
		if (module_index + 7 <= module_len && module[module_index] == 0xff && module[module_index + 1] == 0xff)
			module_index += 2;
	}
	return false;
}

int get_packed_ext(string filename)
{
	int ext = 0;
	for (int i = filename.Length; --i > 0; ) {
		int c = filename[i];
		if (c <= ' ' || c > 'z')
			return 0;
		if (c == '.')
			return ext | 0x202020;
		ext = (ext << 8) + c;
	}
	return 0;
}

macro ASAP_EXT(s) ( s[0] + s[1] << 8 + s[2] << 16 | 0x202020 )

bool is_our_ext(int ext)
{
	switch (ext) {
	case ASAP_EXT("SAP"):
#if !ASAP_ONLY_SAP
	case ASAP_EXT("CMC"):
	case ASAP_EXT("CM3"):
	case ASAP_EXT("CMR"):
	case ASAP_EXT("CMS"):
	case ASAP_EXT("DMC"):
	case ASAP_EXT("DLT"):
	case ASAP_EXT("MPT"):
	case ASAP_EXT("MPD"):
	case ASAP_EXT("RMT"):
	case ASAP_EXT("TMC"):
	case ASAP_EXT("TM8"):
	case ASAP_EXT("TM2"):
#endif
		return true;
	default:
		return false;
	}
}

public bool ASAP_IsOurFile(string filename)
{
	return is_our_ext(get_packed_ext(filename));
}

public bool ASAP_IsOurExt(string ext)
{
	return ext.Length == 3 && is_our_ext(ASAP_EXT(ext));
}

bool parse_file(ASAP_State ast, ASAP_ModuleInfo module_info, string filename, byte[] module, int module_len)
{
	int len = filename.Length;
	int basename = 0;
	int ext = -1;
	for (int i = 0; i < len; i++) {
		int c = filename[i];
		if (c == '/' || c == '\\') {
			basename = i + 1;
			ext = -1;
		}
		else if (c == '.')
			ext = i;
	}
	if (ext < 0)
		return false;
	module_info.author = "";
	module_info.name = filename.Substring(basename, ext - basename);
	module_info.date = "";
	module_info.channels = 1;
	module_info.songs = 1;
	module_info.default_song = 0;
	for (int i = 0; i < SongsMax; i++) {
		module_info.durations[i] = -1;
		module_info.loops[i] = false;
	}
	module_info.ntsc = false;
	module_info.fastplay = 312;
	module_info.music = -1;
	module_info.init = -1;
	module_info.player = -1;
	module_info.covox_addr = -1;
	switch (get_packed_ext(filename)) {
	case ASAP_EXT("SAP"):
		return parse_sap(ast, module_info, module, module_len);
#if !ASAP_ONLY_SAP
	case ASAP_EXT("CMC"):
		return parse_cmc(ast, module_info, module, module_len, TypeCMC, GET_PLAYER(cmc));
	case ASAP_EXT("CM3"):
		return parse_cmc(ast, module_info, module, module_len, TypeCM3, GET_PLAYER(cm3));
	case ASAP_EXT("CMR"):
		return parse_cmc(ast, module_info, module, module_len, TypeCMR, GET_PLAYER(cmc));
	case ASAP_EXT("CMS"):
		module_info.channels = 2;
		return parse_cmc(ast, module_info, module, module_len, TypeCMS, GET_PLAYER(cms));
	case ASAP_EXT("DMC"):
		module_info.fastplay = 156;
		return parse_cmc(ast, module_info, module, module_len, TypeCMC, GET_PLAYER(cmc));
	case ASAP_EXT("DLT"):
		return parse_dlt(ast, module_info, module, module_len);
	case ASAP_EXT("MPT"):
		return parse_mpt(ast, module_info, module, module_len);
	case ASAP_EXT("MPD"):
		module_info.fastplay = 156;
		return parse_mpt(ast, module_info, module, module_len);
	case ASAP_EXT("RMT"):
		return parse_rmt(ast, module_info, module, module_len);
	case ASAP_EXT("TMC"):
	case ASAP_EXT("TM8"):
		return parse_tmc(ast, module_info, module, module_len);
	case ASAP_EXT("TM2"):
		return parse_tm2(ast, module_info, module, module_len);
#endif
	default:
		return false;
	}
}

public bool ASAP_GetModuleInfo(ASAP_ModuleInfo module_info, string filename, byte[] module, int module_len)
{
	return parse_file(null, module_info, filename, module, module_len);
}

#if !ASAP_ONLY_INFO

public bool ASAP_Load(ASAP_State ast, string filename, byte[] module, int module_len)
{
	ast.silence_cycles = 0;
	return parse_file(ast, ast.module_info, filename, module, module_len);
}

public void ASAP_DetectSilence(ASAP_State ast, int seconds)
{
	ast.silence_cycles = seconds * ASAP_MAIN_CLOCK(ast);
}

void call_6502(ASAP_State ast, int addr, int max_scanlines)
{
	ast.cpu_pc = addr;
	// put a CIM at 0xd20a and a return address on stack
	dPutByte(0xd20a, 0xd2);
	dPutByte(0x01fe, 0x09);
	dPutByte(0x01ff, 0xd2);
	ast.cpu_s = 0xfd;
	Cpu_RunScanlines(ast, max_scanlines);
}

void call_6502_init(ASAP_State ast, int addr, int a, int x, int y)
{
	ast.cpu_a = a & 0xff;
	ast.cpu_x = x & 0xff;
	ast.cpu_y = y & 0xff;
	// 50 Atari frames for the initialization routine - some SAPs are self-extracting
	call_6502(ast, addr, 50 * 312);
}

public void ASAP_MutePokeyChannels(ASAP_State ast, int mask)
{
	PokeySound_Mute(ast, ast.base_pokey, mask);
	PokeySound_Mute(ast, ast.extra_pokey, mask >> 4);
}

void ASAP_PlaySong(ASAP_State ast, int song, int duration)
{
	ast.current_song = song;
	ast.current_duration = duration;
	ast.blocks_played = 0;
	ast.silence_cycles_counter = ast.silence_cycles;
	ast.extra_pokey_mask = ast.module_info.channels > 1 ? 0x10 : 0;
	ast.consol = 8;
	ast.nmist = NmistOnVBlank;
	ast.covox[0] = 0x80;
	ast.covox[1] = 0x80;
	ast.covox[2] = 0x80;
	ast.covox[3] = 0x80;
	PokeySound_Initialize(ast);
	ast.cycle = 0;
	ast.cpu_nz = 0;
	ast.cpu_c = 0;
	ast.cpu_vdi = 0;
	ast.scanline_number = 0;
	ast.next_scanline_cycle = 0;
	ast.timer1_cycle = NeverCycle;
	ast.timer2_cycle = NeverCycle;
	ast.timer4_cycle = NeverCycle;
	ast.irqst = 0xff;
	switch (ast.module_info.type) {
	case TypeSAP_B:
		call_6502_init(ast, ast.module_info.init, song, 0, 0);
		break;
	case TypeSAP_C:
#if !ASAP_ONLY_SAP
	case TypeCMC:
	case TypeCM3:
	case TypeCMR:
	case TypeCMS:
#endif
		call_6502_init(ast, ast.module_info.player + 3, 0x70, ast.module_info.music, ast.module_info.music >> 8);
		call_6502_init(ast, ast.module_info.player + 3, 0x00, song, 0);
		break;
	case TypeSAP_D:
	case TypeSAP_S:
		ast.cpu_a = song;
		ast.cpu_x = 0x00;
		ast.cpu_y = 0x00;
		ast.cpu_s = 0xff;
		ast.cpu_pc = ast.module_info.init;
		break;
#if !ASAP_ONLY_SAP
	case TypeDLT:
		call_6502_init(ast, ast.module_info.player + 0x100, 0x00, 0x00, ast.module_info.song_pos[song]);
		break;
	case TypeMPT:
		call_6502_init(ast, ast.module_info.player, 0x00, ast.module_info.music >> 8, ast.module_info.music);
		call_6502_init(ast, ast.module_info.player, 0x02, ast.module_info.song_pos[song], 0);
		break;
	case TypeRMT:
		call_6502_init(ast, ast.module_info.player, ast.module_info.song_pos[song], ast.module_info.music, ast.module_info.music >> 8);
		break;
	case TypeTMC:
	case TypeTM2:
		call_6502_init(ast, ast.module_info.player, 0x70, ast.module_info.music >> 8, ast.module_info.music);
		call_6502_init(ast, ast.module_info.player, 0x00, song, 0);
		ast.tmc_per_frame_counter = 1;
		break;
#endif
	}
	ASAP_MutePokeyChannels(ast, 0);
}

bool call_6502_player(ASAP_State ast)
{
	PokeySound_StartFrame(ast);
	int player = ast.module_info.player;
	switch (ast.module_info.type) {
	case TypeSAP_B:
		call_6502(ast, player, ast.module_info.fastplay);
		break;
	case TypeSAP_C:
#if !ASAP_ONLY_SAP
	case TypeCMC:
	case TypeCM3:
	case TypeCMR:
	case TypeCMS:
#endif
		call_6502(ast, player + 6, ast.module_info.fastplay);
		break;
	case TypeSAP_D:
		if (player >= 0) {
			int s = ast.cpu_s;
			macro PUSH_ON_6502_STACK(x)  { dPutByte(0x100 + s, x); s = (s - 1) & 0xff; }
			// save 6502 state on 6502 stack
			PUSH_ON_6502_STACK(ast.cpu_pc >> 8);
			PUSH_ON_6502_STACK(ast.cpu_pc & 0xff);
			PUSH_ON_6502_STACK(((ast.cpu_nz | (ast.cpu_nz >> 1)) & 0x80) + ast.cpu_vdi +
				(ast.cpu_nz & 0xff == 0 ? CpuZFlag : 0) + ast.cpu_c + 0x20);
			PUSH_ON_6502_STACK(ast.cpu_a);
			PUSH_ON_6502_STACK(ast.cpu_x);
			PUSH_ON_6502_STACK(ast.cpu_y);
			// RTS will jump to 6502 code that restores the state
			const int ReturnFromPlayerAddr = 0xd200;
			PUSH_ON_6502_STACK((ReturnFromPlayerAddr - 1) >> 8);
			PUSH_ON_6502_STACK((ReturnFromPlayerAddr - 1) & 0xff);
			ast.cpu_s = s;
			dPutByte(ReturnFromPlayerAddr, 0x68);     // PLA
			dPutByte(ReturnFromPlayerAddr + 1, 0xa8); // TAY
			dPutByte(ReturnFromPlayerAddr + 2, 0x68); // PLA
			dPutByte(ReturnFromPlayerAddr + 3, 0xaa); // TAX
			dPutByte(ReturnFromPlayerAddr + 4, 0x68); // PLA
			dPutByte(ReturnFromPlayerAddr + 5, 0x40); // RTI
			ast.cpu_pc = player;
		}
		Cpu_RunScanlines(ast, ast.module_info.fastplay);
		break;
	case TypeSAP_S:
		Cpu_RunScanlines(ast, ast.module_info.fastplay);
		{
			int i = dGetByte(0x45) - 1;
			dPutByte(0x45, i);
			if (i == 0)
				dPutByte(0xb07b, dGetByte(0xb07b) + 1);
		}
		break;
#if !ASAP_ONLY_SAP
	case TypeDLT:
		call_6502(ast, player + 0x103, ast.module_info.fastplay);
		break;
	case TypeMPT:
	case TypeRMT:
	case TypeTM2:
		call_6502(ast, player + 3, ast.module_info.fastplay);
		break;
	case TypeTMC:
		if (--ast.tmc_per_frame_counter <= 0) {
			ast.tmc_per_frame_counter = ast.tmc_per_frame;
			call_6502(ast, player + 3, ast.module_info.fastplay);
		}
		else
			call_6502(ast, player + 6, ast.module_info.fastplay);
		break;
#endif
	}
	PokeySound_EndFrame(ast, ast.module_info.fastplay * 114);
	if (ast.silence_cycles > 0) {
		if (PokeySound_IsSilent(ast.base_pokey)
		 && PokeySound_IsSilent(ast.extra_pokey)) {
			ast.silence_cycles_counter -= ast.module_info.fastplay * 114;
			if (ast.silence_cycles_counter <= 0)
				return false;
		}
		else
			ast.silence_cycles_counter = ast.silence_cycles;
	}
	return true;
}

public int ASAP_GetPosition(ASAP_State ast)
{
	return ast.blocks_played * 10 / (SampleRate / 100);
}

public int milliseconds_to_blocks(int milliseconds)
{
	return milliseconds * (SampleRate / 100) / 10;
}

public void ASAP_Seek(ASAP_State ast, int position)
{
	int block = milliseconds_to_blocks(position);
	if (block < ast.blocks_played)
		ASAP_PlaySong(ast, ast.current_song, ast.current_duration);
	while (ast.blocks_played + ast.samples - ast.sample_index < block) {
		ast.blocks_played += ast.samples - ast.sample_index;
		call_6502_player(ast);
	}
	ast.sample_index += block - ast.blocks_played;
	ast.blocks_played = block;
}

void serialize_int(byte[] buffer, int offset, int value)
{
	buffer[offset] = value.LowByte;
	buffer[offset + 1] = (value >> 8).LowByte;
	buffer[offset + 2] = (value >> 16).LowByte;
	buffer[offset + 3] = (value >> 24).LowByte;
}

public void ASAP_GetWavHeader(ASAP_State ast, byte[] buffer, ASAP_SampleFormat format)
{
	int use_16bit = format != ASAP_SampleFormat.U8 ? 1 : 0;
	int block_size = ast.module_info.channels << use_16bit;
	int bytes_per_second = SampleRate * block_size;
	int total_blocks = milliseconds_to_blocks(ast.current_duration);
	int n_bytes = (total_blocks - ast.blocks_played) * block_size;
	buffer[0] = 'R';
	buffer[1] = 'I';
	buffer[2] = 'F';
	buffer[3] = 'F';
	serialize_int(buffer, 4, n_bytes + 36);
	buffer[8] = 'W';
	buffer[9] = 'A';
	buffer[10] = 'V';
	buffer[11] = 'E';
	buffer[12] = 'f';
	buffer[13] = 'm';
	buffer[14] = 't';
	buffer[15] = ' ';
	buffer[16] = 16;
	buffer[17] = 0;
	buffer[18] = 0;
	buffer[19] = 0;
	buffer[20] = 1;
	buffer[21] = 0;
	buffer[22] = ast.module_info.channels;
	buffer[23] = 0;
	serialize_int(buffer, 24, SampleRate);
	serialize_int(buffer, 28, bytes_per_second);
	buffer[32] = block_size;
	buffer[33] = 0;
	buffer[34] = 8 << use_16bit;
	buffer[35] = 0;
	buffer[36] = 'd';
	buffer[37] = 'a';
	buffer[38] = 't';
	buffer[39] = 'a';
	serialize_int(buffer, 40, n_bytes);
}

int ASAP_GenerateAt(ASAP_State ast, byte[] buffer, int buffer_offset, int buffer_len, ASAP_SampleFormat format)
{
	if (ast.silence_cycles > 0 && ast.silence_cycles_counter <= 0)
		return 0;
	int block_shift =
#if FLASH
		0;
#else
		(ast.module_info.channels - 1) + (format != ASAP_SampleFormat.U8 ? 1 : 0);
#endif
	int buffer_blocks = buffer_len >> block_shift;
	if (ast.current_duration > 0) {
		int total_blocks = milliseconds_to_blocks(ast.current_duration);
		if (buffer_blocks > total_blocks - ast.blocks_played)
			buffer_blocks = total_blocks - ast.blocks_played;
	}
	int block = 0;
	do {
		int blocks = PokeySound_Generate(ast, buffer, buffer_offset + (block << block_shift), buffer_blocks - block, format);
		ast.blocks_played += blocks;
		block += blocks;
	} while (block < buffer_blocks && call_6502_player(ast));
	return block << block_shift;
}

public int ASAP_Generate(ASAP_State ast, byte[] buffer, int buffer_len, ASAP_SampleFormat format)
{
	return ASAP_GenerateAt(ast, buffer, 0, buffer_len, format);
}

#endif // ASAP_ONLY_INFO
