// cpu6502.ci - 6502 CPU emulator
//
// Copyright (C) 2010-2014  Piotr Fusik
//
// This file is part of ASAP (Another Slight Atari Player),
// see http://asap.sourceforge.net
//
// ASAP is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published
// by the Free Software Foundation; either version 2 of the License,
// or (at your option) any later version.
//
// ASAP is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty
// of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with ASAP; if not, write to the Free Software Foundation, Inc.,
// 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

// How 6502 registers are stored in this emulator:
// All variables are int, because modern processors (and Java bytecode)
// tend to operate more effectively on these type than narrower ones.
// pc is really an unsigned 16-bit integer.
// a, x, y and s are unsigned 8-bit integers.
// Flags are decomposed into three variables for improved performance.
// c is either 0 or 1.
// nz contains 6502 flags N and Z.
// N is set if (nz >= 0x80). Z is set if ((nz & 0xff) == 0).
// Usually nz is simply assigned the unsigned 8-bit operation result.
// There are just a few operations (BIT, PLP and RTI) where both N and Z may
// be set. In these cases, N is reflected by the 8th (not 7th) bit of nz.
// vdi contains rarely used flags V, D and I, as a combination
// of VFlag, DFlag and IFlag. Other vdi bits are clear.

// "Unofficial" opcodes are those not documented as "legal" 6502 opcodes.
// Their operation has been reverse-engineered on Atari 800XL and Atari 65XE.
// Unofficial opcodes are identical to C64's 6510, except for 0x8b and 0xab.
// The operation of "unstable" opcodes is partially uncertain.
// Explanation is welcome.

// Emulation of POKEY timer interrupts is included.

class Cpu6502
{
	int Pc;
	int A;
	int X;
	int Y;
	int S;
	int Nz;
	int C;
	int Vdi;

	const int VFlag = 0x40;
	const int DFlag = 0x08;
	const int IFlag = 0x04;
	const int ZFlag = 0x02;

	/// Runs 6502 emulation for the specified number of Atari scanlines.
	/// Each scanline is 114 cycles of which 9 is taken by ANTIC for memory refresh.
	void DoFrame(ASAP asap, int cycleLimit)
	{
		// copy registers from the object to local variables for improved performance
		int pc = Pc;
		int nz = Nz;
		int a = A;
		int x = X;
		int y = Y;
		int c = C;
		int s = S;
		int vdi = Vdi;

		while (asap.Cycle < cycleLimit) {

			macro PEEK_MEMORY(addr)       ( asap.Memory[addr] )
			macro POKE_MEMORY(addr, data) { asap.Memory[addr] = data; }

			macro PEEK_ZPAGE(addr)        ( PEEK_MEMORY((addr) & 0xff) )
			macro DPEEK_MEMORY(addr)      ( PEEK_MEMORY(addr) + (PEEK_MEMORY((addr) + 1) << 8) )

			macro PEEK(addr)              ( ((addr) & 0xf900) == 0xd000 ? asap.PeekHardware(addr) : PEEK_MEMORY(addr) )
			macro POKE(addr, data)        { if (((addr) & 0xf900) == 0xd000) asap.PokeHardware(addr, data); else POKE_MEMORY(addr, data); }

			macro PEEK_RMW(dest, addr) {
				if ((addr) >> 8 == 0xd2) {
					asap.Cycle--;
					dest = asap.PeekHardware(addr);
					asap.PokeHardware(addr, dest);
					asap.Cycle++;
				}
				else
					dest = PEEK_MEMORY(addr);
			}

			macro PEEK_CODE()  ( PEEK_MEMORY(pc) )
			macro FETCH()      ( PEEK_MEMORY(pc++) )

			macro ABSOLUTE()   { addr = FETCH(); addr += FETCH() << 8; }
			macro ABSOLUTE_X() { addr = FETCH(); addr = (addr + (FETCH() << 8) + x) & 0xffff; }
			macro ABSOLUTE_Y() { addr = FETCH(); addr = (addr + (FETCH() << 8) + y) & 0xffff; }
			macro INDIRECT_Y() { addr = FETCH(); addr = (PEEK_MEMORY(addr) + (PEEK_ZPAGE(addr + 1) << 8) + y) & 0xffff; }
			macro NCYCLES_Y()  { if ((addr & 0xff) < y) asap.Cycle++; }

			macro PL(dest)     { s = (s + 1) & 0xff; dest = PEEK_MEMORY(0x0100 + s); }
			macro PLP()        { PL(vdi); nz = ((vdi & 0x80) << 1) + (~vdi & ZFlag); c = vdi & 1; vdi &= VFlag | DFlag | IFlag; }
			macro PH(data)     { POKE_MEMORY(0x0100 + s, data); s = (s - 1) & 0xff; }
			macro PHP(bflag)   { PH(((nz | (nz >> 1)) & 0x80) + vdi + ((nz & 0xff) == 0 ? ZFlag : 0) + c + bflag); }
			macro PHPB0()      { PHP(0x20); }  // push flags with B flag clear (NMI, IRQ)
			macro PHPB1()      { PHP(0x30); }  // push flags with B flag set (PHP, BRK)
			macro PHPC()       { PH(pc >> 8); PH(pc.LowByte); }

			macro DO_ADC() {{
				int tmp = a + data + c;
				nz = tmp & 0xff;
				if ((vdi & DFlag) == 0) {
					// binary mode
					vdi = (vdi & (DFlag | IFlag)) + (((~(data ^ a) & (a ^ tmp)) >> 1) & VFlag);
					c = tmp >> 8;
					a = nz;
				}
				else {
					// decimal mode
					int al = (a & 0x0f) + (data & 0x0f) + c;
					if (al >= 10) {
						tmp += al < 26 ? 6 : -10;
						// Set N from tmp, leave Z unchanged. Zero can only change to 6, this doesn't affect N.
						if (nz != 0)
							nz = (tmp & 0x80) + 1;
					}
					vdi = (vdi & (DFlag | IFlag)) + (((~(data ^ a) & (a ^ tmp)) >> 1) & VFlag);
					if (tmp >= 0xa0) {
						c = 1;
						a = (tmp + 0x60) & 0xff;
					}
					else {
						c = 0;
						a = tmp;
					}
				}
			}}

			macro DO_SBC() {{
				int tmp = a - data - 1 + c;
				int al = (a & 0x0f) - (data & 0x0f) - 1 + c;
				vdi = (vdi & (DFlag | IFlag)) + ((((data ^ a) & (a ^ tmp)) >> 1) & VFlag);
				c = tmp >= 0 ? 1 : 0;
				nz = a = tmp & 0xff;
				if ((vdi & DFlag) != 0) {
					// decimal mode
					if (al < 0)
						a += al < -10 ? 10 : -6;
					if (c == 0)
						a = (a - 0x60) & 0xff;
				}
			}}

			macro ASL()        { PEEK_RMW(nz, addr); c = nz >> 7; nz = (nz << 1) & 0xff; POKE(addr, nz); }
			macro ROL()        { PEEK_RMW(nz, addr); nz = (nz << 1) + c; c = nz >> 8; nz &= 0xff; POKE(addr, nz); }
			macro LSR()        { PEEK_RMW(nz, addr); c = nz & 1; nz >>= 1; POKE(addr, nz); }
			macro ROR()        { PEEK_RMW(nz, addr); nz += c << 8; c = nz & 1; nz >>= 1; POKE(addr, nz); }
			macro DEC()        { PEEK_RMW(nz, addr); nz = (nz - 1) & 0xff; POKE(addr, nz); }
			macro INC()        { PEEK_RMW(nz, addr); nz = (nz + 1) & 0xff; POKE(addr, nz); }

			macro SHX(val,ind) {{
				addr = FETCH();
				int hi = FETCH();
				data = (hi + 1) & val;
				addr += ind;
				if (addr >= 0x100)
					hi = data - 1;
				addr += hi << 8;
				POKE(addr, data);
			}}

			macro CHECK_IRQ()  {
				if ((vdi & IFlag) == 0 && asap.Pokeys.BasePokey.Irqst != 0xff) {
					PHPC();
					PHPB0();
					vdi |= IFlag;
					pc = DPEEK_MEMORY(0xfffe);
					asap.Cycle += 7;
				}
			}

			if (asap.Cycle >= asap.NextEventCycle) {
				Pc = pc;
				S = s;
				asap.HandleEvent();
				pc = Pc;
				s = S;
				CHECK_IRQ();
			}
#if ASAPSCAN
			native {
				if (cpu_trace != 0)
					trace_cpu(asap, pc, a, x, y, s, nz, vdi, c);
			}
#endif
			int data = FETCH();
			const int[256] opcodeCycles = {
			//	0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
				7, 6, 2, 8, 3, 3, 5, 5, 3, 2, 2, 2, 4, 4, 6, 6, // 0x
				2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7, // 1x
				6, 6, 2, 8, 3, 3, 5, 5, 4, 2, 2, 2, 4, 4, 6, 6, // 2x
				2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7, // 3x
				6, 6, 2, 8, 3, 3, 5, 5, 3, 2, 2, 2, 3, 4, 6, 6, // 4x
				2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7, // 5x
				6, 6, 2, 8, 3, 3, 5, 5, 4, 2, 2, 2, 5, 4, 6, 6, // 6x
				2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7, // 7x
				2, 6, 2, 6, 3, 3, 3, 3, 2, 2, 2, 2, 4, 4, 4, 4, // 8x
				2, 6, 2, 6, 4, 4, 4, 4, 2, 5, 2, 5, 5, 5, 5, 5, // 9x
				2, 6, 2, 6, 3, 3, 3, 3, 2, 2, 2, 2, 4, 4, 4, 4, // Ax
				2, 5, 2, 5, 4, 4, 4, 4, 2, 4, 2, 4, 4, 4, 4, 4, // Bx
				2, 6, 2, 8, 3, 3, 5, 5, 2, 2, 2, 2, 4, 4, 6, 6, // Cx
				2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7, // Dx
				2, 6, 2, 8, 3, 3, 5, 5, 2, 2, 2, 2, 4, 4, 6, 6, // Ex
				2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7  // Fx
			};
			asap.Cycle += opcodeCycles[data];
			int addr = 0; // This initialization is only to avoid false "uninitialized value used" warnings and errors.

			// First dispatch on opcode.
			// Handles execution of instructions with fixed addressing modes (code ends with `continue`)
			// and computes effective address for instructions with variable addressing mode
			// (code ends with `break" to pass to the second `switch`).
			switch (data) {
			case 0x00: // BRK
				pc++;
				PHPC();
				PHPB1();
				vdi |= IFlag;
				pc = DPEEK_MEMORY(0xfffe);
				continue;
			case 0x01: // ORA (ab,x)
			case 0x03: // ASO (ab,x) [unofficial]
			case 0x21: // AND (ab,x)
			case 0x23: // RLA (ab,x) [unofficial]
			case 0x41: // EOR (ab,x)
			case 0x43: // LSE (ab,x) [unofficial]
			case 0x61: // ADC (ab,x)
			case 0x63: // RRA (ab,x) [unofficial]
			case 0x81: // STA (ab,x)
			case 0x83: // SAX (ab,x) [unofficial]
			case 0xa1: // LDA (ab,x)
			case 0xa3: // LAX (ab,x) [unofficial]
			case 0xc1: // CMP (ab,x)
			case 0xc3: // DCM (ab,x) [unofficial]
			case 0xe1: // SBC (ab,x)
			case 0xe3: // INS (ab,x) [unofficial]
				addr = (FETCH() + x) & 0xff;
				addr = PEEK_MEMORY(addr) + (PEEK_ZPAGE(addr + 1) << 8);
				break;
			case 0x02: // CIM [unofficial]
			case 0x12:
			case 0x22:
			case 0x32:
			case 0x42:
			case 0x52:
			case 0x62:
			case 0x72:
			case 0x92:
			case 0xb2:
			case 0xd2:
			case 0xf2:
				pc--;
				asap.Cycle = asap.NextEventCycle;
				continue;
			case 0x04: // NOP ab [unofficial]
			case 0x44:
			case 0x64:
			case 0x14: // NOP ab,x [unofficial]
			case 0x34:
			case 0x54:
			case 0x74:
			case 0xd4:
			case 0xf4:
			case 0x80: // NOP #ab [unofficial]
			case 0x82:
			case 0x89:
			case 0xc2:
			case 0xe2:
				pc++;
				continue;
			case 0x05: // ORA ab
			case 0x06: // ASL ab
			case 0x07: // ASO ab [unofficial]
			case 0x24: // BIT ab
			case 0x25: // AND ab
			case 0x26: // ROL ab
			case 0x27: // RLA ab [unofficial]
			case 0x45: // EOR ab
			case 0x46: // LSR ab
			case 0x47: // LSE ab [unofficial]
			case 0x65: // ADC ab
			case 0x66: // ROR ab
			case 0x67: // RRA ab [unofficial]
			case 0x84: // STY ab
			case 0x85: // STA ab
			case 0x86: // STX ab
			case 0x87: // SAX ab [unofficial]
			case 0xa4: // LDY ab
			case 0xa5: // LDA ab
			case 0xa6: // LDX ab
			case 0xa7: // LAX ab [unofficial]
			case 0xc4: // CPY ab
			case 0xc5: // CMP ab
			case 0xc6: // DEC ab
			case 0xc7: // DCM ab [unofficial]
			case 0xe4: // CPX ab
			case 0xe5: // SBC ab
			case 0xe6: // INC ab
			case 0xe7: // INS ab [unofficial]
				addr = FETCH();
				break;
			case 0x08: // PHP
				PHPB1();
				continue;
			case 0x09: // ORA #ab
			case 0x29: // AND #ab
			case 0x49: // EOR #ab
			case 0x69: // ADC #ab
			case 0xa0: // LDY #ab
			case 0xa2: // LDX #ab
			case 0xa9: // LDA #ab
			case 0xc0: // CPY #ab
			case 0xc9: // CMP #ab
			case 0xe0: // CPX #ab
			case 0xe9: // SBC #ab
			case 0xeb: // SBC #ab [unofficial]
				addr = pc++;
				break;
			case 0x0a: // ASL
				c = a >> 7;
				nz = a = (a << 1) & 0xff;
				continue;
			case 0x0b: // ANC #ab [unofficial]
			case 0x2b:
				nz = a &= FETCH();
				c = nz >> 7;
				continue;
			case 0x0c: // NOP abcd [unofficial]
				pc += 2;
				continue;
			case 0x0d: // ORA abcd
			case 0x0e: // ASL abcd
			case 0x0f: // ASO abcd [unofficial]
			case 0x2c: // BIT abcd
			case 0x2d: // AND abcd
			case 0x2e: // ROL abcd
			case 0x2f: // RLA abcd [unofficial]
			case 0x4d: // EOR abcd
			case 0x4e: // LSR abcd
			case 0x4f: // LSE abcd [unofficial]
			case 0x6c: // JMP (abcd)
			case 0x6d: // ADC abcd
			case 0x6e: // ROR abcd
			case 0x6f: // RRA abcd [unofficial]
			case 0x8c: // STY abcd
			case 0x8d: // STA abcd
			case 0x8e: // STX abcd
			case 0x8f: // SAX abcd [unofficial]
			case 0xac: // LDY abcd
			case 0xad: // LDA abcd
			case 0xae: // LDX abcd
			case 0xaf: // LAX abcd [unofficial]
			case 0xcc: // CPY abcd
			case 0xcd: // CMP abcd
			case 0xce: // DEC abcd
			case 0xcf: // DCM abcd [unofficial]
			case 0xec: // CPX abcd
			case 0xed: // SBC abcd
			case 0xee: // INC abcd
			case 0xef: // INS abcd [unofficial]
				addr = FETCH();
				addr += FETCH() << 8;
				break;
			case 0x10: // BPL
				if (nz < 0x80)
					break;
				pc++;
				continue;
			case 0x11: // ORA (ab),y
			case 0x31: // AND (ab),y
			case 0x51: // EOR (ab),y
			case 0x71: // ADC (ab),y
			case 0xb1: // LDA (ab),y
			case 0xb3: // LAX (ab),y [unofficial]
			case 0xd1: // CMP (ab),y
			case 0xf1: // SBC (ab),y
				INDIRECT_Y();
				NCYCLES_Y();
				break;
			case 0x13: // ASO (ab),y [unofficial]
			case 0x33: // RLA (ab),y [unofficial]
			case 0x53: // LSE (ab),y [unofficial]
			case 0x73: // RRA (ab),y [unofficial]
			case 0x91: // STA (ab),y
			case 0xd3: // DCM (ab),y [unofficial]
			case 0xf3: // INS (ab),y [unofficial]
				INDIRECT_Y();
				break;
			case 0x15: // ORA ab,x
			case 0x16: // ASL ab,x
			case 0x17: // ASO ab,x [unofficial]
			case 0x35: // AND ab,x
			case 0x36: // ROL ab,x
			case 0x37: // RLA ab,x [unofficial]
			case 0x55: // EOR ab,x
			case 0x56: // LSR ab,x
			case 0x57: // LSE ab,x [unofficial]
			case 0x75: // ADC ab,x
			case 0x76: // ROR ab,x
			case 0x77: // RRA ab,x [unofficial]
			case 0x94: // STY ab,x
			case 0x95: // STA ab,x
			case 0xb4: // LDY ab,x
			case 0xb5: // LDA ab,x
			case 0xd5: // CMP ab,x
			case 0xd6: // DEC ab,x
			case 0xd7: // DCM ab,x [unofficial]
			case 0xf5: // SBC ab,x
			case 0xf6: // INC ab,x
			case 0xf7: // INS ab,x [unofficial]
				addr = (FETCH() + x) & 0xff;
				break;
			case 0x18: // CLC
				c = 0;
				continue;
			case 0x19: // ORA abcd,y
			case 0x39: // AND abcd,y
			case 0x59: // EOR abcd,y
			case 0x79: // ADC abcd,y
			case 0xb9: // LDA abcd,y
			case 0xbb: // LAS abcd,y [unofficial, unstable]
			case 0xbe: // LDX abcd,y
			case 0xbf: // LAX abcd,y [unofficial]
			case 0xd9: // CMP abcd,y
			case 0xf9: // SBC abcd,y
				ABSOLUTE_Y();
				NCYCLES_Y();
				break;
			case 0x1b: // ASO abcd,y [unofficial]
			case 0x3b: // RLA abcd,y [unofficial]
			case 0x5b: // LSE abcd,y [unofficial]
			case 0x7b: // RRA abcd,y [unofficial]
			case 0x99: // STA abcd,y
			case 0xdb: // DCM abcd,y [unofficial]
			case 0xfb: // INS abcd,y [unofficial]
				ABSOLUTE_Y();
				break;
			case 0x1c: // NOP abcd,x [unofficial]
			case 0x3c:
			case 0x5c:
			case 0x7c:
			case 0xdc:
			case 0xfc:
				if (FETCH() + x >= 0x100)
					asap.Cycle++;
				pc++;
				continue;
			case 0x1d: // ORA abcd,x
			case 0x3d: // AND abcd,x
			case 0x5d: // EOR abcd,x
			case 0x7d: // ADC abcd,x
			case 0xbc: // LDY abcd,x
			case 0xbd: // LDA abcd,x
			case 0xdd: // CMP abcd,x
			case 0xfd: // SBC abcd,x
				ABSOLUTE_X();
				if ((addr & 0xff) < x)
					asap.Cycle++;
				break;
			case 0x1e: // ASL abcd,x
			case 0x1f: // ASO abcd,x [unofficial]
			case 0x3e: // ROL abcd,x
			case 0x3f: // RLA abcd,x [unofficial]
			case 0x5e: // LSR abcd,x
			case 0x5f: // LSE abcd,x [unofficial]
			case 0x7e: // ROR abcd,x
			case 0x7f: // RRA abcd,x [unofficial]
			case 0x9d: // STA abcd,x
			case 0xde: // DEC abcd,x
			case 0xdf: // DCM abcd,x [unofficial]
			case 0xfe: // INC abcd,x
			case 0xff: // INS abcd,x [unofficial]
				ABSOLUTE_X();
				break;
			case 0x20: // JSR abcd
				addr = FETCH();
				PHPC();
				pc = addr + (PEEK_CODE() << 8);
				continue;
			case 0x28: // PLP
				PLP();
				CHECK_IRQ();
				continue;
			case 0x2a: // ROL
				a = (a << 1) + c;
				c = a >> 8;
				nz = a &= 0xff;
				continue;
			case 0x30: // BMI
				if (nz >= 0x80)
					break;
				pc++;
				continue;
			case 0x38: // SEC
				c = 1;
				continue;
			case 0x40: // RTI
				PLP();
				PL(pc);
				PL(addr);
				pc += addr << 8;
				CHECK_IRQ();
				continue;
			case 0x48: // PHA
				PH(a);
				continue;
			case 0x4a: // LSR
				c = a & 1;
				nz = a >>= 1;
				continue;
			case 0x4b: // ALR #ab [unofficial]
				a &= FETCH();
				c = a & 1;
				nz = a >>= 1;
				continue;
			case 0x4c: // JMP abcd
				addr = FETCH();
				pc = addr + (PEEK_CODE() << 8);
				continue;
			case 0x50: // BVC
				if ((vdi & VFlag) == 0)
					break;
				pc++;
				continue;
			case 0x58: // CLI
				vdi &= VFlag | DFlag;
				CHECK_IRQ();
				continue;
			case 0x60: // RTS
				PL(pc);
				PL(addr);
				pc += (addr << 8) + 1;
				continue;
			case 0x68: // PLA
				PL(a);
				nz = a;
				continue;
			case 0x6a: // ROR
				nz = (c << 7) + (a >> 1);
				c = a & 1;
				a = nz;
				continue;
			case 0x6b: // ARR #ab [unofficial]
				data = a & FETCH();
				nz = a = (data >> 1) + (c << 7);
				vdi = (vdi & (DFlag | IFlag)) + ((a ^ data) & VFlag);
				if ((vdi & DFlag) == 0)
					c = data >> 7;
				else {
					if ((data & 0xf) >= 5)
						a = (a & 0xf0) + ((a + 6) & 0xf);
					if (data >= 0x50) {
						a = (a + 0x60) & 0xff;
						c = 1;
					}
					else
						c = 0;
				}
				continue;
			case 0x70: // BVS
				if ((vdi & VFlag) != 0)
					break;
				pc++;
				continue;
			case 0x78: // SEI
				vdi |= IFlag;
				continue;
			case 0x88: // DEY
				nz = y = (y - 1) & 0xff;
				continue;
			case 0x8a: // TXA
				nz = a = x;
				continue;
			case 0x8b: // ANE #ab [unofficial]
				data = FETCH();
				a &= (data | 0xef) & x;
				nz = a & data;
				continue;
			case 0x90: // BCC
				if (c == 0)
					break;
				pc++;
				continue;
			case 0x93: // SHA (ab),y [unofficial, unstable]
				{
					addr = FETCH();
					int hi = PEEK_ZPAGE(addr + 1);
					addr = PEEK_MEMORY(addr);
					data = (hi + 1) & a & x;
					addr += y;
					if (addr >= 0x100)
						hi = data - 1;
					addr += hi << 8;
					POKE(addr, data);
				}
				continue;
			case 0x96: // STX ab,y
			case 0x97: // SAX ab,y [unofficial]
			case 0xb6: // LDX ab,y
			case 0xb7: // LAX ab,y [unofficial]
				addr = (FETCH() + y) & 0xff;
				break;
			case 0x98: // TYA
				nz = a = y;
				continue;
			case 0x9a: // TXS
				s = x;
				continue;
			case 0x9b: // SHS abcd,y [unofficial, unstable]
				// S seems to be stable, only memory values vary
				s = a & x;
				SHX(s, y);
				continue;
			case 0x9c: // SHY abcd,x [unofficial]
				SHX(y, x);
				continue;
			case 0x9e: // SHX abcd,y [unofficial]
				SHX(x, y);
				continue;
			case 0x9f: // SHA abcd,y [unofficial, unstable]
				SHX(a & x, y);
				continue;
			case 0xa8: // TAY
				nz = y = a;
				continue;
			case 0xaa: // TAX
				nz = x = a;
				continue;
			case 0xab: // ANX #ab [unofficial]
				nz = x = a &= FETCH();
				continue;
			case 0xb0: // BCS
				if (c != 0)
					break;
				pc++;
				continue;
			case 0xb8: // CLV
				vdi &= DFlag | IFlag;
				continue;
			case 0xba: // TSX
				nz = x = s;
				continue;
			case 0xc8: // INY
				nz = y = (y + 1) & 0xff;
				continue;
			case 0xca: // DEX
				nz = x = (x - 1) & 0xff;
				continue;
			case 0xcb: // SBX #ab [unofficial]
				nz = FETCH();
				x &= a;
				c = x >= nz ? 1 : 0;
				nz = x = (x - nz) & 0xff;
				continue;
			case 0xd0: // BNE
				if ((nz & 0xff) != 0)
					break;
				pc++;
				continue;
			case 0xd8: // CLD
				vdi &= VFlag | IFlag;
				continue;
			case 0xe8: // INX
				nz = x = (x + 1) & 0xff;
				continue;
			case 0xea: // NOP
			case 0x1a: // NOP [unofficial]
			case 0x3a:
			case 0x5a:
			case 0x7a:
			case 0xda:
			case 0xfa:
				continue;
			case 0xf0: // BEQ
				if ((nz & 0xff) == 0)
					break;
				pc++;
				continue;
			case 0xf8: // SED
				vdi |= DFlag;
				continue;
			default: // we handled all the 256 cases, yet gcc 4.8.3 still complains about the uninitialized `addr`
				continue;
			}

			// Second dispatch on opcode.
			// Handles execution of instructions with variable addressing mode.
			// The address has been decoded to `addr`.
			switch (data) {
			case 0x01: // ORA (ab,x)
			case 0x05: // ORA ab
			case 0x09: // ORA #ab
			case 0x0d: // ORA abcd
			case 0x11: // ORA (ab),y
			case 0x15: // ORA ab,x
			case 0x19: // ORA abcd,y
			case 0x1d: // ORA abcd,x
				nz = a |= PEEK(addr);
				break;
			case 0x03: // ASO (ab,x) [unofficial]
			case 0x07: // ASO ab [unofficial]
			case 0x0f: // ASO abcd [unofficial]
			case 0x13: // ASO (ab),y [unofficial]
			case 0x17: // ASO ab,x [unofficial]
			case 0x1b: // ASO abcd,y [unofficial]
			case 0x1f: // ASO abcd,x [unofficial]
				ASL();
				nz = a |= nz;
				break;
			case 0x06: // ASL ab
			case 0x0e: // ASL abcd
			case 0x16: // ASL ab,x
			case 0x1e: // ASL abcd,x
				ASL();
				break;
			case 0x10: // BPL
			case 0x30: // BMI
			case 0x50: // BVC
			case 0x70: // BVS
			case 0x90: // BCC
			case 0xb0: // BCS
			case 0xd0: // BNE
			case 0xf0: // BEQ
				addr = PEEK_CODE().SByte;
				pc++;
				addr += pc;
				if ((addr ^ pc) >> 8 != 0)
					asap.Cycle++;
				asap.Cycle++;
				pc = addr;
				break;
			case 0x21: // AND (ab,x)
			case 0x25: // AND ab
			case 0x29: // AND #ab
			case 0x2d: // AND abcd
			case 0x31: // AND (ab),y
			case 0x35: // AND ab,x
			case 0x39: // AND abcd,y
			case 0x3d: // AND abcd,x
				nz = a &= PEEK(addr);
				break;
			case 0x23: // RLA (ab,x) [unofficial]
			case 0x27: // RLA ab [unofficial]
			case 0x2f: // RLA abcd [unofficial]
			case 0x33: // RLA (ab),y [unofficial]
			case 0x37: // RLA ab,x [unofficial]
			case 0x3b: // RLA abcd,y [unofficial]
			case 0x3f: // RLA abcd,x [unofficial]
				ROL();
				nz = a &= nz;
				break;
			case 0x24: // BIT ab
			case 0x2c: // BIT abcd
				nz = PEEK(addr);
				vdi = (vdi & (DFlag | IFlag)) + (nz & VFlag);
				nz = ((nz & 0x80) << 1) + (nz & a);
				break;
			case 0x26: // ROL ab
			case 0x2e: // ROL abcd
			case 0x36: // ROL ab,x
			case 0x3e: // ROL abcd,x
				ROL();
				break;
			case 0x41: // EOR (ab,x)
			case 0x45: // EOR ab
			case 0x49: // EOR #ab
			case 0x4d: // EOR abcd
			case 0x51: // EOR (ab),y
			case 0x55: // EOR ab,x
			case 0x59: // EOR abcd,y
			case 0x5d: // EOR abcd,x
				nz = a ^= PEEK(addr);
				break;
			case 0x43: // LSE (ab,x) [unofficial]
			case 0x47: // LSE ab [unofficial]
			case 0x4f: // LSE abcd [unofficial]
			case 0x53: // LSE (ab),y [unofficial]
			case 0x57: // LSE ab,x [unofficial]
			case 0x5b: // LSE abcd,y [unofficial]
			case 0x5f: // LSE abcd,x [unofficial]
				LSR();
				nz = a ^= nz;
				break;
			case 0x46: // LSR ab
			case 0x4e: // LSR abcd
			case 0x56: // LSR ab,x
			case 0x5e: // LSR abcd,x
				LSR();
				break;
			case 0x61: // ADC (ab,x)
			case 0x65: // ADC ab
			case 0x69: // ADC #ab
			case 0x6d: // ADC abcd
			case 0x71: // ADC (ab),y
			case 0x75: // ADC ab,x
			case 0x79: // ADC abcd,y
			case 0x7d: // ADC abcd,x
				data = PEEK(addr);
				DO_ADC();
				break;
			case 0x63: // RRA (ab,x) [unofficial]
			case 0x67: // RRA ab [unofficial]
			case 0x6f: // RRA abcd [unofficial]
			case 0x73: // RRA (ab),y [unofficial]
			case 0x77: // RRA ab,x [unofficial]
			case 0x7b: // RRA abcd,y [unofficial]
			case 0x7f: // RRA abcd,x [unofficial]
				ROR();
				data = nz;
				DO_ADC();
				break;
			case 0x66: // ROR ab
			case 0x6e: // ROR abcd
			case 0x76: // ROR ab,x
			case 0x7e: // ROR abcd,x
				ROR();
				break;
			case 0x6c: // JMP (abcd)
				if ((addr & 0xff) == 0xff)
					pc = PEEK_MEMORY(addr) + (PEEK_MEMORY(addr - 0xff) << 8);
				else
					pc = DPEEK_MEMORY(addr);
				break;
			case 0x81: // STA (ab,x)
			case 0x85: // STA ab
			case 0x8d: // STA abcd
			case 0x91: // STA (ab),y
			case 0x95: // STA ab,x
			case 0x99: // STA abcd,y
			case 0x9d: // STA abcd,x
				POKE(addr, a);
				break;
			case 0x83: // SAX (ab,x) [unofficial]
			case 0x87: // SAX ab [unofficial]
			case 0x8f: // SAX abcd [unofficial]
			case 0x97: // SAX ab,y [unofficial]
				data = a & x;
				POKE(addr, data);
				break;
			case 0x84: // STY ab
			case 0x8c: // STY abcd
			case 0x94: // STY ab,x
				POKE(addr, y);
				break;
			case 0x86: // STX ab
			case 0x8e: // STX abcd
			case 0x96: // STX ab,y
				POKE(addr, x);
				break;
			case 0xa0: // LDY #ab
			case 0xa4: // LDY ab
			case 0xac: // LDY abcd
			case 0xb4: // LDY ab,x
			case 0xbc: // LDY abcd,x
				nz = y = PEEK(addr);
				break;
			case 0xa1: // LDA (ab,x)
			case 0xa5: // LDA ab
			case 0xa9: // LDA #ab
			case 0xad: // LDA abcd
			case 0xb1: // LDA (ab),y
			case 0xb5: // LDA ab,x
			case 0xb9: // LDA abcd,y
			case 0xbd: // LDA abcd,x
				nz = a = PEEK(addr);
				break;
			case 0xa2: // LDX #ab
			case 0xa6: // LDX ab
			case 0xae: // LDX abcd
			case 0xb6: // LDX ab,y
			case 0xbe: // LDX abcd,y
				nz = x = PEEK(addr);
				break;
			case 0xa3: // LAX (ab,x) [unofficial]
			case 0xa7: // LAX ab [unofficial]
			case 0xaf: // LAX abcd [unofficial]
			case 0xb3: // LAX (ab),y [unofficial]
			case 0xb7: // LAX ab,y [unofficial]
			case 0xbf: // LAX abcd,y [unofficial]
				nz = x = a = PEEK(addr);
				break;
			case 0xbb: // LAS abcd,y [unofficial, unstable]
				// only Z is unstable
				nz = x = a = s &= PEEK(addr);
				break;
			case 0xc0: // CPY #ab
			case 0xc4: // CPY ab
			case 0xcc: // CPY abcd
				nz = PEEK(addr);
				c = y >= nz ? 1 : 0;
				nz = (y - nz) & 0xff;
				break;
			case 0xc1: // CMP (ab,x)
			case 0xc5: // CMP ab
			case 0xc9: // CMP #ab
			case 0xcd: // CMP abcd
			case 0xd1: // CMP (ab),y
			case 0xd5: // CMP ab,x
			case 0xd9: // CMP abcd,y
			case 0xdd: // CMP abcd,x
				nz = PEEK(addr);
				c = a >= nz ? 1 : 0;
				nz = (a - nz) & 0xff;
				break;
			case 0xc3: // DCM (ab,x) [unofficial]
			case 0xc7: // DCM ab [unofficial]
			case 0xcf: // DCM abcd [unofficial]
			case 0xd3: // DCM (ab),y [unofficial]
			case 0xd7: // DCM ab,x [unofficial]
			case 0xdb: // DCM abcd,y [unofficial]
			case 0xdf: // DCM abcd,x [unofficial]
				DEC();
				c = a >= nz ? 1 : 0;
				nz = (a - nz) & 0xff;
				break;
			case 0xc6: // DEC ab
			case 0xce: // DEC abcd
			case 0xd6: // DEC ab,x
			case 0xde: // DEC abcd,x
				DEC();
				break;
			case 0xe0: // CPX #ab
			case 0xe4: // CPX ab
			case 0xec: // CPX abcd
				nz = PEEK(addr);
				c = x >= nz ? 1 : 0;
				nz = (x - nz) & 0xff;
				break;
			case 0xe1: // SBC (ab,x)
			case 0xe5: // SBC ab
			case 0xe9: // SBC #ab
			case 0xeb: // SBC #ab [unofficial]
			case 0xed: // SBC abcd
			case 0xf1: // SBC (ab),y
			case 0xf5: // SBC ab,x
			case 0xf9: // SBC abcd,y
			case 0xfd: // SBC abcd,x
				data = PEEK(addr);
				DO_SBC();
				break;
			case 0xe3: // INS (ab,x) [unofficial]
			case 0xe7: // INS ab [unofficial]
			case 0xef: // INS abcd [unofficial]
			case 0xf3: // INS (ab),y [unofficial]
			case 0xf7: // INS ab,x [unofficial]
			case 0xfb: // INS abcd,y [unofficial]
			case 0xff: // INS abcd,x [unofficial]
				INC();
				data = nz;
				DO_SBC();
				break;
			case 0xe6: // INC ab
			case 0xee: // INC abcd
			case 0xf6: // INC ab,x
			case 0xfe: // INC abcd,x
				INC();
				break;
			}
		}
		Pc = pc;
		Nz = nz;
		A = a;
		X = x;
		Y = y;
		C = c;
		S = s;
		Vdi = vdi;
	}
}
