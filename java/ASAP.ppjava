/*
 * ASAP.ppjava - Java version of ASAP
 *
 * Copyright (C) 2007  Piotr Fusik
 *
 * This file is part of ASAP (Another Slight Atari Player),
 * see http://asap.sourceforge.net
 *
 * ASAP is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published
 * by the Free Software Foundation; either version 2 of the License,
 * or (at your option) any later version.
 *
 * ASAP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ASAP; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

#define JAVA
#define abool                   boolean
#define FALSE                   false
#define TRUE                    true
#define NULL                    null
#define const
#define CONST_LOOKUP            private static final
#define FILE_FUNC               private static
#define ASAP_FUNC               private static
#define PTR
#define ADDRESSOF
#define VOIDPTR                 byte[]
#define UBYTE(data)             ((data) & 0xff)
#define SBYTE                   byte
#define STRING                  String
#define SET_STRING(dest, src)   dest = src
#define sizeof(array)           array.length
#define ZERO_ARRAY(array)       for (int ii = 0; ii < array.length; ii++) array[ii] = 0
#define COPY_ARRAY(dest, dest_offset, src, src_offset, len) \
                                System.arraycopy(src, src_offset, dest, dest_offset, len)
#define NEW_ARRAY(type, size)   [] = new type[size]
#define INIT_BOOL_ARRAY(array)

#define AS                      as.
#define PS                      ps.
#define MODULE_INFO             module_info.
#define ASAP_SAMPLE_RATE        44100
#define ASAP_FORMAT_U8          8
#define ASAP_FORMAT_S16_LE      16
#define ASAP_FORMAT_S16_BE      -16
#define ASAP_SampleFormat       int
#define ASAP_Player             InputStream
#define PLAYER_OBX(name)        ASAP.class.getResourceAsStream(#name + ".obx")

package net.sf.asap;

import java.io.InputStream;
import java.io.IOException;

class PokeyState
{
	int audctl;
	int poly_index;
	int div_cycles;
	int mute1;
	int mute2;
	int mute3;
	int mute4;
	int audf1;
	int audf2;
	int audf3;
	int audf4;
	int audc1;
	int audc2;
	int audc3;
	int audc4;
	int tick_cycle1;
	int tick_cycle2;
	int tick_cycle3;
	int tick_cycle4;
	int period_cycles1;
	int period_cycles2;
	int period_cycles3;
	int period_cycles4;
	int reload_cycles1;
	int reload_cycles3;
	int out1;
	int out2;
	int out3;
	int out4;
	int delta1;
	int delta2;
	int delta3;
	int delta4;
	byte[] delta_buffer = new byte[1024];
}

class ASAP_State
{
	int cycle;
	int cpu_pc;
	int cpu_a;
	int cpu_x;
	int cpu_y;
	int cpu_s;
	int cpu_nz;
	int cpu_c;
	int cpu_vdi;
	int scanline_number;
	int nearest_event_cycle;
	int next_scanline_cycle;
	int timer1_cycle;
	int timer2_cycle;
	int timer4_cycle;
	int irqst;
	PokeyState base_pokey = new PokeyState();
	PokeyState extra_pokey = new PokeyState();
	int sample_offset;
	int sample_index;
	int samples;
	int iir_acc_left;
	int iir_acc_right;
	public ASAP_ModuleInfo module_info = new ASAP_ModuleInfo();
	char sap_type;
	int sap_player;
	int sap_music;
	int sap_init;
	int sap_fastplay;
	int tmc_per_frame;
	int tmc_per_frame_counter;
	int current_song;
	int current_duration;
	int blocks_played;
	int silence_cycles;
	int silence_cycles_counter;
	byte[] song_pos = new byte[128];
	byte[] poly9_lookup = new byte[511];
	byte[] poly17_lookup = new byte[16385];
	byte[] memory = new byte[65536];
}

/** Another Slight Atari Player.
    It interprets music files created for 8-bit Atari computers,
    emulates the 6502 processor and the POKEY sound chip
    and generates audio samples.  ASAP performs no I/O operations
    - music data must be passed in byte arrays. */
public final class ASAP
{

#include "acpu.c"
#include "apokeysnd.c"
#include "asap.c"

	private final ASAP_State as = new ASAP_State();

	/** ASAP version. */
	public static final String VERSION = "0.4.0";

	/** Maximum length of a supported input file.
	    You can assume that files longer than this are not supported by ASAP. */
	public static final int MODULE_MAX = 65000;

	/** Output sample rate. */
	public static final int SAMPLE_RATE = ASAP_SAMPLE_RATE;

	/** Output format: 8-bit unsigned. */
	public static final int FORMAT_U8 = ASAP_FORMAT_U8;

	/** Output format: 16-bit signed little-endian. */
	public static final int FORMAT_S16_LE = ASAP_FORMAT_S16_LE;

	/** Output format: 16-bit signed big-endian. */
	public static final int FORMAT_S16_BE = ASAP_FORMAT_S16_BE;

	/** Creates a new instance of the player.
	    The first method you call on the new object must be <code>load</code>. */
	public ASAP()
	{
	}

	/** Checks whether the extension of the passed filename is known to ASAP.
	    @param filename filename to check
	    @return <code>true</code> if filename is supported by ASAP */
	public static boolean isOurFile(String filename)
	{
		return ASAP_IsOurFile(filename);
	}

	/** Returns information about a module.
	    @param filename determines file format
	    @param module contents of the file
	    @param module_len length of the file
	    @return file information */
	public static ASAP_ModuleInfo getModuleInfo(String filename, byte[] module, int module_len)
	{
		ASAP_ModuleInfo module_info = new ASAP_ModuleInfo();
		if (!ASAP_GetModuleInfo(module_info, filename, module, module_len))
			throw new IllegalArgumentException();
		return module_info;
	}

	/** Parses a string in the <code>"mm:ss.xxx"</code> format
	    and returns the number of milliseconds represented by the string.
	    @param s string representation of time
	    @return number of milliseconds represented by the string */
	public static int parseDuration(String s)
	{
		int i = s.indexOf(':');
		int r = 0;
		if (i >= 0) {
			r = Integer.parseInt(s.substring(0, i)) * 60000;
			s = s.substring(i + 1);
		}
		i = s.indexOf(' ');
		if (i >= 0)
			s = s.substring(0, i);
		r += (int) (Double.parseDouble(s) * 1000);
		return r;
	}

	/** Loads music data.
	    @param filename determines file format
	    @param module contents of the file
	    @param module_len length of the file */
	public void load(String filename, byte[] module, int module_len)
	{
		if (!ASAP_Load(as, filename, module, module_len))
			throw new IllegalArgumentException();
	}

	/** Returns information about the loaded module.
	    @return information about the loaded module */
	public ASAP_ModuleInfo getModuleInfo()
	{
		return as.module_info;
	}

	/** Prepares ASAP to play the specified song of the loaded module.
	    @param song zero-based song index
		@param duration playback time in milliseconds,
	    -1 means indefinitely */
	public void playSong(int song, int duration)
	{
		ASAP_PlaySong(as, song, duration);
	}

	/** Rewinds the current song.
	    @param position the requested absolute position in milliseconds */
	public void seek(int position)
	{
		ASAP_Seek(as, position);
	}

	/** Fills the specified buffer with generated samples.
	    @param buffer the destination buffer
	    @param format format of samples
	    @return number of bytes written in the buffer
	    (less than <code>buffer.length</code> if reached the end of the song) */
	public int generate(byte[] buffer, int format)
	{
		return ASAP_Generate(as, buffer, buffer.length, format);
	}

	/** Returns POKEY channel volume.
	    @param channel POKEY channel number (from 1 to 8)
	    @return volume of the specified channel (from 0 to 15) */
	public int getPokeyChannelVolume(int channel)
	{
		switch (channel) {
		case 1:
			return as.base_pokey.audf1 & 0xf;
		case 2:
			return as.base_pokey.audf2 & 0xf;
		case 3:
			return as.base_pokey.audf3 & 0xf;
		case 4:
			return as.base_pokey.audf4 & 0xf;
		case 5:
			return as.extra_pokey.audf1 & 0xf;
		case 6:
			return as.extra_pokey.audf2 & 0xf;
		case 7:
			return as.extra_pokey.audf3 & 0xf;
		case 8:
			return as.extra_pokey.audf4 & 0xf;
		default:
			return 0;
		}
	}
}
