// apokeysnd.ci - ASAP in the Ci programming language
//
// Copyright (C) 2010-2011  Piotr Fusik
//
// This file is part of ASAP (Another Slight Atari Player),
// see http://asap.sourceforge.net
//
// ASAP is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published
// by the Free Software Foundation; either version 2 of the License,
// or (at your option) any later version.
//
// ASAP is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty
// of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with ASAP; if not, write to the Free Software Foundation, Inc.,
// 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

class PokeyState
{
	int audctl;
	bool init;
	int poly_index;
	int div_cycles;
	int mute1;
	int mute2;
	int mute3;
	int mute4;
	int audf1;
	int audf2;
	int audf3;
	int audf4;
	int audc1;
	int audc2;
	int audc3;
	int audc4;
	int tick_cycle1;
	int tick_cycle2;
	int tick_cycle3;
	int tick_cycle4;
	int period_cycles1;
	int period_cycles2;
	int period_cycles3;
	int period_cycles4;
	int reload_cycles1;
	int reload_cycles3;
	int out1;
	int out2;
	int out3;
	int out4;
	int delta1;
	int delta2;
	int delta3;
	int delta4;
	int skctl;
	int[888] delta_buffer;
}

// TODO: flags
const int MuteFrequency = 1;
const int MuteInit = 2;
const int MuteUser = 4;
const int MuteSerialInput = 8;

void PokeySound_InitializeChip(PokeyState pst)
{
	pst.audctl = 0;
	pst.init = false;
	pst.poly_index = 15 * 31 * 131071;
	pst.div_cycles = 28;
	pst.mute1 = MuteFrequency | MuteUser;
	pst.mute2 = MuteFrequency | MuteUser;
	pst.mute3 = MuteFrequency | MuteUser;
	pst.mute4 = MuteFrequency | MuteUser;
	pst.audf1 = 0;
	pst.audf2 = 0;
	pst.audf3 = 0;
	pst.audf4 = 0;
	pst.audc1 = 0;
	pst.audc2 = 0;
	pst.audc3 = 0;
	pst.audc4 = 0;
	pst.tick_cycle1 = NeverCycle;
	pst.tick_cycle2 = NeverCycle;
	pst.tick_cycle3 = NeverCycle;
	pst.tick_cycle4 = NeverCycle;
	pst.period_cycles1 = 28;
	pst.period_cycles2 = 28;
	pst.period_cycles3 = 28;
	pst.period_cycles4 = 28;
	pst.reload_cycles1 = 28;
	pst.reload_cycles3 = 28;
	pst.out1 = 0;
	pst.out2 = 0;
	pst.out3 = 0;
	pst.out4 = 0;
	pst.delta1 = 0;
	pst.delta2 = 0;
	pst.delta3 = 0;
	pst.delta4 = 0;
	pst.skctl = 3;
	pst.delta_buffer.Clear();
}

void PokeySound_Initialize(ASAP_State ast)
{
	int reg = 0x1ff;
	for (int i = 0; i < 511; i++) {
		reg = (reg >> 5 ^ reg) & 1 << 8 + reg >> 1;
		ast.poly9_lookup[i] = reg.LowByte;
	}
	reg = 0x1ffff;
	for (int i = 0; i < 16385; i++) {
		reg = (reg >> 5 ^ reg) & 0xff << 9 + reg >> 8;
		ast.poly17_lookup[i] = (reg >> 1).LowByte;
	}
	ast.sample_offset = 0;
	ast.sample_index = 0;
	ast.samples = 0;
	ast.iir_acc_left = 0;
	ast.iir_acc_right = 0;
	PokeySound_InitializeChip(ast.base_pokey);
	PokeySound_InitializeChip(ast.extra_pokey);
}

/// Fills `delta_buffer` up to `current_cycle` basing on current AUDF/AUDC/AUDCTL values.
void PokeySound_GenerateUntilCycle(ASAP_State ast, PokeyState pst, int current_cycle)
{
	for (;;) {
		int cycle = current_cycle;
		if (cycle > pst.tick_cycle1)
			cycle = pst.tick_cycle1;
		if (cycle > pst.tick_cycle2)
			cycle = pst.tick_cycle2;
		if (cycle > pst.tick_cycle3)
			cycle = pst.tick_cycle3;
		if (cycle > pst.tick_cycle4)
			cycle = pst.tick_cycle4;
		if (cycle == current_cycle)
			break;

		const byte[15] poly4_lookup = { 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1 };
		const byte[31] poly5_lookup = {
			0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1,
			0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1 };
		macro DO_TICK(ch) {
			if (pst.init) {
				switch (pst.audc##ch >> 4) {
				case 10:
				case 14:
					pst.out##ch ^= 1;
					pst.delta_buffer[CYCLE_TO_SAMPLE(cycle)] += pst.delta##ch = -pst.delta##ch;
					break;
				default:
					break;
				}
			}
			else {
				int poly = cycle + pst.poly_index - (ch - 1);
				int newout = pst.out##ch;
				switch (pst.audc##ch >> 4) {
				case 0:
					if (poly5_lookup[poly % 31] != 0) {
						if (pst.audctl & 0x80 != 0)
							newout = ast.poly9_lookup[poly % 511] & 1;
						else {
							poly %= 131071;
							newout = (ast.poly17_lookup[poly >> 3] >> (poly & 7)) & 1;
						}
					}
					break;
				case 2:
				case 6:
					newout ^= poly5_lookup[poly % 31];
					break;
				case 4:
					if (poly5_lookup[poly % 31] != 0)
						newout = poly4_lookup[poly % 15];
					break;
				case 8:
					if (pst.audctl & 0x80 != 0)
						newout = ast.poly9_lookup[poly % 511] & 1;
					else {
						poly %= 131071;
						newout = (ast.poly17_lookup[poly >> 3] >> (poly & 7)) & 1;
					}
					break;
				case 10:
				case 14:
					newout ^= 1;
					break;
				case 12:
					newout = poly4_lookup[poly % 15];
					break;
				default:
					break;
				}
				if (newout != pst.out##ch) {
					pst.out##ch = newout;
					pst.delta_buffer[CYCLE_TO_SAMPLE(cycle)] += pst.delta##ch = -pst.delta##ch;
				}
			}
		}

		if (cycle == pst.tick_cycle3) {
			pst.tick_cycle3 += pst.period_cycles3;
			if (pst.audctl & 4 != 0 && pst.delta1 > 0 && pst.mute1 == 0)
				pst.delta_buffer[CYCLE_TO_SAMPLE(cycle)] += pst.delta1 = -pst.delta1;
			DO_TICK(3);
		}
		if (cycle == pst.tick_cycle4) {
			pst.tick_cycle4 += pst.period_cycles4;
			if (pst.audctl & 8 != 0)
				pst.tick_cycle3 = cycle + pst.reload_cycles3;
			if (pst.audctl & 2 != 0 && pst.delta2 > 0 && pst.mute2 == 0)
				pst.delta_buffer[CYCLE_TO_SAMPLE(cycle)] += pst.delta2 = -pst.delta2;
			DO_TICK(4);
		}
		if (cycle == pst.tick_cycle1) {
			pst.tick_cycle1 += pst.period_cycles1;
			if (pst.skctl & 0x88 == 8) // two-tone, sending 1 (i.e. timer1)
				pst.tick_cycle2 = cycle + pst.period_cycles2;
			DO_TICK(1);
		}
		if (cycle == pst.tick_cycle2) {
			pst.tick_cycle2 += pst.period_cycles2;
			if (pst.audctl & 0x10 != 0)
				pst.tick_cycle1 = cycle + pst.reload_cycles1;
			else if (pst.skctl & 8 != 0) // two-tone
				pst.tick_cycle1 = cycle + pst.period_cycles1;
			DO_TICK(2);
		}
	}
}

#if APOKEYSND
macro CURRENT_CYCLE()  (0)
macro CURRENT_SAMPLE() (0)
macro DO_STORE(reg) {
	if (data == pst.reg)
		break;
	pst.reg = data;
}
#else
macro CURRENT_CYCLE()  (ast.cycle)
macro CURRENT_SAMPLE() (CYCLE_TO_SAMPLE(ast.cycle))
macro DO_STORE(reg) {
	if (data == pst.reg)
		break;
	PokeySound_GenerateUntilCycle(ast, pst, ast.cycle);
	pst.reg = data;
}
#endif // APOKEYSND

macro MUTE_CHANNEL(ch, cond, mask) {
	if (cond) {
		pst.mute##ch |= mask;
		pst.tick_cycle##ch = NeverCycle;
	}
	else {
		pst.mute##ch &= ~mask;
		if (pst.tick_cycle##ch == NeverCycle && pst.mute##ch == 0)
			pst.tick_cycle##ch = CURRENT_CYCLE();
	}
}

void PokeySound_PutByte(ASAP_State ast, int addr, int data)
{
	PokeyState pst = addr & ast.extra_pokey_mask != 0 ? ast.extra_pokey : ast.base_pokey;
	switch (addr & 0xf) {
	case 0x00:
		DO_STORE(audf1);
		const int UltrasoundCycles = 112;
		macro DO_ULTRASOUND(ch) {
			MUTE_CHANNEL(ch, pst.period_cycles##ch <= UltrasoundCycles
				&& (pst.audc##ch >> 4 == 10 || pst.audc##ch >> 4 == 14), MuteFrequency);
		}
		switch (pst.audctl & 0x50) {
		case 0x00:
			pst.period_cycles1 = pst.div_cycles * (data + 1);
			break;
		case 0x10:
			pst.period_cycles2 = pst.div_cycles * (data + 256 * pst.audf2 + 1);
			pst.reload_cycles1 = pst.div_cycles * (data + 1);
			DO_ULTRASOUND(2);
			break;
		case 0x40:
			pst.period_cycles1 = data + 4;
			break;
		case 0x50:
			pst.period_cycles2 = data + 256 * pst.audf2 + 7;
			pst.reload_cycles1 = data + 4;
			DO_ULTRASOUND(2);
			break;
		}
		DO_ULTRASOUND(1);
		break;
	case 0x01:
		macro DO_AUDC(ch) {
			DO_STORE(audc##ch);
			if (data & 0x10 != 0) {
				data = (data & 0xf) << DeltaShiftPOKEY;
				if (pst.mute##ch & MuteUser == 0)
					pst.delta_buffer[CURRENT_SAMPLE()]
						+= pst.delta##ch > 0 ? data - pst.delta##ch : data;
				pst.delta##ch = data;
			}
			else {
				data = (data & 0xf) << DeltaShiftPOKEY;
				DO_ULTRASOUND(ch);
				if (pst.delta##ch > 0) {
					if (pst.mute##ch & MuteUser == 0)
						pst.delta_buffer[CURRENT_SAMPLE()]
							+= data - pst.delta##ch;
					pst.delta##ch = data;
				}
				else
					pst.delta##ch = -data;
			}
			break;
		}
		DO_AUDC(1);
	case 0x02:
		DO_STORE(audf2);
		switch (pst.audctl & 0x50) {
		case 0x00:
		case 0x40:
			pst.period_cycles2 = pst.div_cycles * (data + 1);
			break;
		case 0x10:
			pst.period_cycles2 = pst.div_cycles * (pst.audf1 + 256 * data + 1);
			break;
		case 0x50:
			pst.period_cycles2 = pst.audf1 + 256 * data + 7;
			break;
		}
		DO_ULTRASOUND(2);
		break;
	case 0x03:
		DO_AUDC(2);
	case 0x04:
		DO_STORE(audf3);
		switch (pst.audctl & 0x28) {
		case 0x00:
			pst.period_cycles3 = pst.div_cycles * (data + 1);
			break;
		case 0x08:
			pst.period_cycles4 = pst.div_cycles * (data + 256 * pst.audf4 + 1);
			pst.reload_cycles3 = pst.div_cycles * (data + 1);
			DO_ULTRASOUND(4);
			break;
		case 0x20:
			pst.period_cycles3 = data + 4;
			break;
		case 0x28:
			pst.period_cycles4 = data + 256 * pst.audf4 + 7;
			pst.reload_cycles3 = data + 4;
			DO_ULTRASOUND(4);
			break;
		}
		DO_ULTRASOUND(3);
		break;
	case 0x05:
		DO_AUDC(3);
	case 0x06:
		DO_STORE(audf4);
		switch (pst.audctl & 0x28) {
		case 0x00:
		case 0x20:
			pst.period_cycles4 = pst.div_cycles * (data + 1);
			break;
		case 0x08:
			pst.period_cycles4 = pst.div_cycles * (pst.audf3 + 256 * data + 1);
			break;
		case 0x28:
			pst.period_cycles4 = pst.audf3 + 256 * data + 7;
			break;
		}
		DO_ULTRASOUND(4);
		break;
	case 0x07:
		DO_AUDC(4);
	case 0x08:
		DO_STORE(audctl);
		pst.div_cycles = data & 1 != 0 ? 114 : 28;
		// TODO: tick_cycles
		switch (data & 0x50) {
		case 0x00:
			pst.period_cycles1 = pst.div_cycles * (pst.audf1 + 1);
			pst.period_cycles2 = pst.div_cycles * (pst.audf2 + 1);
			break;
		case 0x10:
			pst.period_cycles1 = pst.div_cycles * 256;
			pst.period_cycles2 = pst.div_cycles * (pst.audf1 + 256 * pst.audf2 + 1);
			pst.reload_cycles1 = pst.div_cycles * (pst.audf1 + 1);
			break;
		case 0x40:
			pst.period_cycles1 = pst.audf1 + 4;
			pst.period_cycles2 = pst.div_cycles * (pst.audf2 + 1);
			break;
		case 0x50:
			pst.period_cycles1 = 256;
			pst.period_cycles2 = pst.audf1 + 256 * pst.audf2 + 7;
			pst.reload_cycles1 = pst.audf1 + 4;
			break;
		}
		DO_ULTRASOUND(1);
		DO_ULTRASOUND(2);
		switch (data & 0x28) {
		case 0x00:
			pst.period_cycles3 = pst.div_cycles * (pst.audf3 + 1);
			pst.period_cycles4 = pst.div_cycles * (pst.audf4 + 1);
			break;
		case 0x08:
			pst.period_cycles3 = pst.div_cycles * 256;
			pst.period_cycles4 = pst.div_cycles * (pst.audf3 + 256 * pst.audf4 + 1);
			pst.reload_cycles3 = pst.div_cycles * (pst.audf3 + 1);
			break;
		case 0x20:
			pst.period_cycles3 = pst.audf3 + 4;
			pst.period_cycles4 = pst.div_cycles * (pst.audf4 + 1);
			break;
		case 0x28:
			pst.period_cycles3 = 256;
			pst.period_cycles4 = pst.audf3 + 256 * pst.audf4 + 7;
			pst.reload_cycles3 = pst.audf3 + 4;
			break;
		}
		DO_ULTRASOUND(3);
		DO_ULTRASOUND(4);
		macro DO_INIT(ch, cond) { MUTE_CHANNEL(ch, pst.init && cond, MuteInit); }
		DO_INIT(1, data & 0x40 == 0);
		DO_INIT(2, data & 0x50 != 0x50);
		DO_INIT(3, data & 0x20 == 0);
		DO_INIT(4, data & 0x28 != 0x28);
		break;
	case 0x09:
		// TODO: reload_cycles, out
		macro DO_STIMER(ch) {
			if (pst.tick_cycle##ch != NeverCycle)
				pst.tick_cycle##ch = ast.cycle + pst.period_cycles##ch;
		}
		DO_STIMER(1);
		DO_STIMER(2);
		DO_STIMER(3);
		DO_STIMER(4);
		break;
	case 0x0f:
		DO_STORE(skctl);
		bool init = data & 3 == 0;
		if (pst.init && !init)
			pst.poly_index = (pst.audctl & 0x80 != 0 ? 15 * 31 * 511 - 1 : 15 * 31 * 131071 - 1) - ast.cycle;
		pst.init = init;
		DO_INIT(1, pst.audctl & 0x40 == 0);
		DO_INIT(2, pst.audctl & 0x50 != 0x50);
		DO_INIT(3, pst.audctl & 0x20 == 0);
		DO_INIT(4, pst.audctl & 0x28 != 0x28);
		MUTE_CHANNEL(3, data & 0x10 != 0, MuteSerialInput);
		MUTE_CHANNEL(4, data & 0x10 != 0, MuteSerialInput);
		break;
	default:
		break;
	}
}

int PokeySound_GetRandom(ASAP_State ast, int addr, int cycle)
{
	PokeyState pst = addr & ast.extra_pokey_mask != 0 ? ast.extra_pokey : ast.base_pokey;
	if (pst.init)
		return 0xff;
	int i = cycle + pst.poly_index;
	if (pst.audctl & 0x80 != 0)
		return ast.poly9_lookup[i % 511];
	else {
		i %= 131071;
		int j = i >> 3;
		i &= 7;
		return (ast.poly17_lookup[j] >> i + ast.poly17_lookup[j + 1] << (8 - i)) & 0xff;
	}
}

void end_frame(ASAP_State ast, PokeyState pst, int cycle_limit)
{
	PokeySound_GenerateUntilCycle(ast, pst, cycle_limit);
	pst.poly_index += cycle_limit;
	int m = pst.audctl & 0x80 != 0 ? 15 * 31 * 511 : 15 * 31 * 131071;
	if (pst.poly_index >= 2 * m)
		pst.poly_index -= m;
	if (pst.tick_cycle1 != NeverCycle)
		pst.tick_cycle1 -= cycle_limit;
	if (pst.tick_cycle2 != NeverCycle)
		pst.tick_cycle2 -= cycle_limit;
	if (pst.tick_cycle3 != NeverCycle)
		pst.tick_cycle3 -= cycle_limit;
	if (pst.tick_cycle4 != NeverCycle)
		pst.tick_cycle4 -= cycle_limit;
}

void PokeySound_StartFrame(ASAP_State ast)
{
	ast.base_pokey.delta_buffer.Clear();
	if (ast.extra_pokey_mask != 0)
		ast.extra_pokey.delta_buffer.Clear();
}

void PokeySound_EndFrame(ASAP_State ast, int current_cycle)
{
	end_frame(ast, ast.base_pokey, current_cycle);
	if (ast.extra_pokey_mask != 0)
		end_frame(ast, ast.extra_pokey, current_cycle);
	ast.sample_offset += current_cycle * SampleRate;
	ast.sample_index = 0;
	int clk = ASAP_MAIN_CLOCK(ast);
	ast.samples = ast.sample_offset / clk;
	ast.sample_offset %= clk;
}

/// Fills buffer with samples from `delta_buffer`.
int PokeySound_Generate(ASAP_State ast, byte[] buffer, int buffer_offset, int blocks, ASAP_SampleFormat format)
{
	int i = ast.sample_index;
	int samples = ast.samples;
	int acc_left = ast.iir_acc_left;
	int acc_right = ast.iir_acc_right;
	if (blocks < samples - i)
		samples = i + blocks;
	else
		blocks = samples - i;
	for (; i < samples; i++) {
		acc_left += ast.base_pokey.delta_buffer[i] - (acc_left * 3 >> 10);
#if FLASH
//		var sample : Number = acc_left / 33553408;
//		buffer.writeFloat(sample);
//		if (ast.extra_pokey_mask != 0) {
//			acc_right += ast.extra_pokey.delta_buffer[i] - (acc_right * 3 >> 10);
//			sample = acc_right / 33553408;
//		}
//		buffer.writeFloat(sample);
#else
		int sample = acc_left >> 10;
		macro STORE_SAMPLE() {
			if (sample < -32767)
				sample = -32767;
			else if (sample > 32767)
				sample = 32767;
			switch (format) {
			case ASAP_SampleFormat.U8:
				buffer[buffer_offset++] = sample >> 8 + 128;
				break;
			case ASAP_SampleFormat.S16LE:
				buffer[buffer_offset++] = sample.LowByte;
				buffer[buffer_offset++] = (sample >> 8).LowByte;
				break;
			case ASAP_SampleFormat.S16BE:
				buffer[buffer_offset++] = (sample >> 8).LowByte;
				buffer[buffer_offset++] = sample.LowByte;
				break;
			}
		}
		STORE_SAMPLE();
		if (ast.extra_pokey_mask != 0) {
			acc_right += ast.extra_pokey.delta_buffer[i] - (acc_right * 3 >> 10);
			sample = acc_right >> 10;
			STORE_SAMPLE();
		}
#endif // FLASH
	}
	if (i == ast.samples) {
		acc_left += ast.base_pokey.delta_buffer[i];
		acc_right += ast.extra_pokey.delta_buffer[i];
	}
	ast.sample_index = i;
	ast.iir_acc_left = acc_left;
	ast.iir_acc_right = acc_right;
#if APOKEYSND
	return buffer_offset;
#else
	return blocks;
#endif
}

bool PokeySound_IsSilent(PokeyState pst)
{
	return (pst.audc1 | pst.audc2 | pst.audc3 | pst.audc4) & 0xf == 0;
}

void PokeySound_Mute(ASAP_State ast, PokeyState pst, int mask)
{
	MUTE_CHANNEL(1, mask & 1 != 0, MuteUser);
	MUTE_CHANNEL(2, mask & 2 != 0, MuteUser);
	MUTE_CHANNEL(3, mask & 4 != 0, MuteUser);
	MUTE_CHANNEL(4, mask & 8 != 0, MuteUser);
}
